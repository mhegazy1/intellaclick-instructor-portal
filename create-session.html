<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Start Session - IntellaClick</title>
    <link rel="stylesheet" href="styles/common.css">
    <link rel="stylesheet" href="styles/create-session.css">
</head>
<body>
    <div class="container">
        <a href="classes.html" class="back-link">
            <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                      d="M10 19l-7-7m0 0l7-7m-7 7h18"></path>
            </svg>
            Back to Classes
        </a>

        <div class="header">
            <h1>Start New Session</h1>
            <div class="class-info" id="classInfo">
                Loading class information...
            </div>
        </div>

        <div class="info-box">
            <h3>Session Types</h3>
            <p>Choose how you want to run your clicker session. You can use the web interface for quick polls or integrate with the desktop app for PowerPoint integration.</p>
        </div>

        <div class="section">
            <h2>Choose Session Type</h2>
            <div class="session-options">
                <div class="option-card" onclick="selectSessionType('quick')" id="quickOption">
                    <h3>Quick Poll</h3>
                    <p>Start a simple multiple choice or true/false poll instantly</p>
                </div>
                <div class="option-card" onclick="selectSessionType('quiz')" id="quizOption">
                    <h3>Quiz Session</h3>
                    <p>Run a prepared quiz with multiple questions</p>
                </div>
                <div class="option-card" onclick="selectSessionType('desktop')" id="desktopOption">
                    <h3>Desktop App</h3>
                    <p>Use with PowerPoint and advanced features</p>
                </div>
            </div>
        </div>

        <div class="section" id="sessionConfig" style="display: none;">
            <h2>Session Configuration</h2>
            <form id="sessionForm">
                <div class="form-group">
                    <label for="sessionName">Session Name</label>
                    <input type="text" id="sessionName" placeholder="e.g., Week 3 Review" required>
                </div>

                <div class="form-group">
                    <label for="customSessionCode">
                        Custom Session Code (Optional)
                        <small style="color: var(--text-secondary); display: block; margin-top: 4px;">
                            Leave blank for random code, or enter your own (e.g., BIO3002025). Same code can be reused for multiple sessions.
                        </small>
                    </label>
                    <input
                        type="text"
                        id="customSessionCode"
                        placeholder="e.g., BIO3002025"
                        maxlength="20"
                        pattern="[A-Za-z0-9]{4,20}"
                        title="4-20 characters, letters and numbers only"
                        style="text-transform: uppercase;"
                    >
                </div>

                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 12px; cursor: pointer; user-select: none;">
                        <input type="checkbox" id="enableGamification" checked style="width: 20px; height: 20px; cursor: pointer;">
                        <span style="display: flex; flex-direction: column; gap: 4px;">
                            <span style="font-weight: 600; font-size: 14px;">üèÜ Enable Gamification</span>
                            <span style="font-size: 12px; color: var(--text-secondary); font-weight: normal;">
                                Students will earn points, achievements, and level up during this session
                            </span>
                        </span>
                    </label>
                </div>

                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 12px; cursor: pointer; user-select: none;">
                        <input type="checkbox" id="autoSaveQuestions" checked style="width: 20px; height: 20px; cursor: pointer;">
                        <span style="display: flex; flex-direction: column; gap: 4px;">
                            <span style="font-weight: 600; font-size: 14px;">üíæ Save Questions for Reuse</span>
                            <span style="font-size: 12px; color: var(--text-secondary); font-weight: normal;">
                                Automatically save this session's questions to "Saved Question Sets" for future use
                            </span>
                        </span>
                    </label>
                </div>

                <div class="form-group" id="quickPollConfig" style="display: none;">
                    <!-- Load Saved Questions Button -->
                    <div style="margin-bottom: 16px;">
                        <button type="button" class="btn btn-secondary" onclick="goToSavedQuestions()" style="width: 100%;">
                            üìÇ Manage Saved Question Sets
                        </button>
                    </div>

                    <!-- Questions List -->
                    <div id="questionsList" style="margin-bottom: 20px;"></div>

                    <label for="questionText">Add Question</label>
                    <textarea id="questionText" rows="3" placeholder="Enter your question here..."></textarea>
                    <button type="button" class="btn btn-secondary" onclick="insertBlank()" style="margin-top: 8px; font-size: 0.9rem; padding: 0.5rem 1rem;">
                        Insert [blank] at cursor
                    </button>

                    <label style="margin-top: 16px;">Question Type</label>
                    <select id="questionType" onchange="updateQuestionOptions()">
                        <option value="mcq">Multiple Choice</option>
                        <option value="poll">Poll (No Correct Answer)</option>
                        <option value="tf">True/False</option>
                        <option value="matching">Matching</option>
                        <option value="ordering">Put in Order</option>
                        <option value="fillblank">Fill in the Blank</option>
                    </select>
                    
                    <!-- Multiple Choice Options -->
                    <div id="mcqOptions" style="margin-top: 16px;">
                        <label>Answer Options</label>
                        <div id="mcqOptionsContainer" class="radio-group" style="flex-direction: column; gap: 10px;">
                            <!-- Options will be added dynamically -->
                        </div>
                        <div style="margin-top: 8px; display: flex; gap: 8px;">
                            <button type="button" class="btn btn-secondary btn-small" onclick="addMcqOption()">+ Add Option</button>
                            <button type="button" class="btn btn-secondary btn-small" onclick="removeMcqOption()">- Remove Last</button>
                        </div>
                        <small style="color: var(--text-secondary); margin-top: 8px; display: block;">Select the radio button next to the correct answer</small>
                    </div>

                    <!-- Poll Options (No Correct Answer) -->
                    <div id="pollOptions" style="margin-top: 16px; display: none;">
                        <label>Poll Options</label>
                        <div id="pollOptionsContainer" style="display: flex; flex-direction: column; gap: 10px;">
                            <!-- Options will be added dynamically -->
                        </div>
                        <div style="margin-top: 8px; display: flex; gap: 8px;">
                            <button type="button" class="btn btn-secondary btn-small" onclick="addPollOption()">+ Add Option</button>
                            <button type="button" class="btn btn-secondary btn-small" onclick="removePollOption()">- Remove Last</button>
                        </div>
                        <div style="margin-top: 12px;">
                            <label style="display: flex; align-items: center; gap: 8px; font-weight: normal; cursor: pointer;">
                                <input type="checkbox" id="pollParticipationPoints" style="width: auto; margin: 0;">
                                <span>Award points for participation (no wrong answer)</span>
                            </label>
                        </div>
                        <small style="color: var(--text-secondary); margin-top: 8px; display: block;">No correct answer - results will show distribution</small>
                    </div>

                    <!-- True/False Options -->
                    <div id="tfOptions" style="margin-top: 16px; display: none;">
                        <label>Correct Answer</label>
                        <div class="radio-group">
                            <div class="radio-option">
                                <input type="radio" name="tfAnswer" value="true" checked>
                                <label>True</label>
                            </div>
                            <div class="radio-option">
                                <input type="radio" name="tfAnswer" value="false">
                                <label>False</label>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Matching Options -->
                    <div id="matchingOptions" style="margin-top: 16px; display: none;">
                        <label>Matching Pairs</label>
                        <div id="matchingPairsContainer" style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 8px;">
                            <!-- Pairs will be added dynamically -->
                        </div>
                        <div style="margin-top: 8px; display: flex; gap: 8px;">
                            <button type="button" class="btn btn-secondary btn-small" onclick="addMatchingPair()">+ Add Pair</button>
                            <button type="button" class="btn btn-secondary btn-small" onclick="removeMatchingPair()">- Remove Last</button>
                        </div>
                    </div>
                    
                    <!-- Ordering Options -->
                    <div id="orderingOptions" style="margin-top: 16px; display: none;">
                        <label>Items in Correct Order</label>
                        <div id="orderingItemsContainer" style="display: flex; flex-direction: column; gap: 8px; margin-top: 8px;">
                            <!-- Items will be added dynamically -->
                        </div>
                        <div style="margin-top: 8px; display: flex; gap: 8px;">
                            <button type="button" class="btn btn-secondary btn-small" onclick="addOrderingItem()">+ Add Item</button>
                            <button type="button" class="btn btn-secondary btn-small" onclick="removeOrderingItem()">- Remove Last</button>
                        </div>
                        <small style="color: var(--text-secondary); margin-top: 8px; display: block;">Enter items in the correct order</small>
                    </div>
                    
                    <!-- Fill in the Blank Options -->
                    <div id="fillblankOptions" style="margin-top: 16px; display: none;">
                        <label>Correct Answer(s)</label>
                        <input type="text" id="blankAnswer" placeholder="Enter the correct answer" style="margin-top: 8px;">
                        <small style="color: var(--text-secondary); margin-top: 8px; display: block;">Use [blank] in your question text where the answer should go</small>
                    </div>

                    <!-- Add Question Button -->
                    <div style="margin-top: 16px; display: flex; gap: 8px;">
                        <button type="button" id="addQuestionBtn" class="btn btn-primary" onclick="addQuickPollQuestion()">+ Add This Question</button>
                        <button type="button" id="cancelEditBtn" class="btn btn-secondary" onclick="cancelEdit()" style="display: none;">Cancel</button>
                    </div>
                </div>

                <div class="form-group" id="quizConfig" style="display: none;">
                    <label for="quizSelect">Select Quiz</label>
                    <select id="quizSelect">
                        <option value="">Loading quizzes...</option>
                    </select>
                    <div id="noQuizzesMessage" style="display: none; margin-top: 12px; padding: 12px; background-color: #FEF3C7; border: 1px solid #FDE68A; border-radius: 8px;">
                        <p style="margin: 0; color: #92400E; font-size: 14px;">
                            No quizzes available yet.
                            <a href="saved-questions.html" style="color: var(--primary-color); font-weight: 500;">Create your first quiz</a>
                        </p>
                    </div>
                </div>

                <div id="desktopInstructions" style="display: none;">
                    <div class="info-box">
                        <h3>Launch from Desktop App</h3>
                        <p>To use PowerPoint integration and advanced features:</p>
                        <ol style="margin-left: 20px; margin-top: 12px;">
                            <li>Open the IntellaClick desktop application</li>
                            <li>Select this class: <strong id="desktopClassName"></strong></li>
                            <li>Click "Start Session" in the desktop app</li>
                            <li>Students can join using code: <strong id="desktopJoinCode"></strong></li>
                        </ol>
                    </div>
                </div>

                <div class="form-group" id="sessionSettings" style="display: block;">
                    <label for="duration">Time Limit (seconds)</label>
                    <input type="number" id="duration" value="60" min="10" max="300">
                </div>

                <div class="form-group" id="sessionOptions" style="display: block;">
                    <label style="display: block; margin-bottom: 8px;">
                        <input type="checkbox" id="allowAnonymous">
                        Allow anonymous responses
                    </label>
                    <label style="display: block; margin-bottom: 8px;">
                        <input type="checkbox" id="openToAll">
                        Open to all (allow non-enrolled students)
                    </label>
                    <label style="display: block; margin-bottom: 8px;">
                        <input type="checkbox" id="allowAnswerChange">
                        Allow students to change their answer
                    </label>
                    <label style="display: block; margin-bottom: 8px;">
                        <input type="checkbox" id="showCorrectAnswer">
                        Show correct answer when question ends
                    </label>
                    <small style="color: var(--text-secondary); display: block; margin-top: 4px;">
                        By default, only enrolled students can join. Check "Open to all" to allow anyone with the code.
                    </small>
                </div>

                <div class="btn-group">
                    <button type="button" class="btn btn-secondary" onclick="cancelSession()">Cancel</button>
                    <button type="submit" class="btn btn-primary" id="startButton">Start Session</button>
                </div>
            </form>
        </div>
    </div>

    <div id="toast" class="toast"></div>

    <script type="module">
        import { auth, sessions, classes as classesAPI } from './utils/api.js';
        import toast from './utils/toast.js';
        import logger from './utils/logger.js';
        import loading from './utils/loading.js';

        let classId;
        let classData;
        let selectedType = null;
        let quickPollQuestions = [];
        let editingQuestionIndex = null; // Track which question is being edited // Store multiple questions for quick poll
        let mcqOptionCount = 4; // Start with 4 options
        let pollOptionCount = 4; // Start with 4 options
        let matchingPairCount = 4; // Start with 4 pairs
        let orderingItemCount = 4; // Start with 4 items

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            const urlParams = new URLSearchParams(window.location.search);
            classId = urlParams.get('classId');

            if (!classId) {
                window.location.href = 'classes.html';
                return;
            }

            checkAuth();
            loadClassInfo();

            // Initialize dynamic options
            initializeMcqOptions(4);
            initializePollOptions(4);
            initializeMatchingPairs(4);
            initializeOrderingItems(4);

            document.getElementById('sessionForm').addEventListener('submit', handleStartSession);

            // Load saved session settings from previous session
            loadSavedSettings();

            // Auto-select Quick Poll if there are saved questions waiting
            const fromSavedSet = sessionStorage.getItem('fromSavedSet');
            const pendingQuestions = sessionStorage.getItem('pendingQuestions');

            logger.debug('üîµ Page loaded - checking for pending questions');
            logger.debug('fromSavedSet:', fromSavedSet);
            logger.debug('pendingQuestions:', pendingQuestions ? 'exists' : 'none');

            if (fromSavedSet === 'true' && pendingQuestions) {
                logger.debug('‚úÖ Auto-selecting Quick Poll mode');
                setTimeout(() => {
                    selectSessionType('quick');
                }, 500); // Small delay to ensure UI is ready
            }
        });

        function checkAuth() {
            const token = localStorage.getItem('token');
            if (!token) {
                window.location.href = 'login.html';
            }
        }

        // Initialize MCQ options with specified count
        function initializeMcqOptions(count) {
            mcqOptionCount = count;
            const container = document.getElementById('mcqOptionsContainer');

            // Save existing values
            const existingValues = {};
            let selectedAnswer = null;
            for (let i = 0; i < 26; i++) {
                const letter = String.fromCharCode(65 + i);
                const input = document.getElementById(`option${letter}`);
                const radio = document.querySelector(`input[name="correctAnswer"][value="${letter}"]`);
                if (input) existingValues[letter] = input.value;
                if (radio && radio.checked) selectedAnswer = letter;
            }

            container.innerHTML = '';

            for (let i = 0; i < count; i++) {
                const letter = String.fromCharCode(65 + i);
                const div = document.createElement('div');
                div.className = 'radio-option';
                div.innerHTML = `
                    <input type="radio" name="correctAnswer" value="${letter}" ${selectedAnswer === letter || (i === 0 && !selectedAnswer) ? 'checked' : ''}>
                    <input type="text" id="option${letter}" placeholder="Option ${letter}" value="${existingValues[letter] || ''}" style="width: calc(100% - 40px); margin-left: 8px;">
                `;
                container.appendChild(div);
            }
        }

        // Initialize Poll options with specified count
        function initializePollOptions(count) {
            pollOptionCount = count;
            const container = document.getElementById('pollOptionsContainer');

            // Save existing values
            const existingValues = {};
            for (let i = 0; i < 26; i++) {
                const letter = String.fromCharCode(65 + i);
                const input = document.getElementById(`pollOption${letter}`);
                if (input) existingValues[letter] = input.value;
            }

            container.innerHTML = '';

            for (let i = 0; i < count; i++) {
                const letter = String.fromCharCode(65 + i);
                const input = document.createElement('input');
                input.type = 'text';
                input.id = `pollOption${letter}`;
                input.placeholder = `Option ${letter}`;
                input.value = existingValues[letter] || '';
                input.style.width = '100%';
                container.appendChild(input);
            }
        }

        // Add MCQ option
        function addMcqOption() {
            if (mcqOptionCount >= 26) {
                toast.error('Maximum 26 options allowed');
                return;
            }
            mcqOptionCount++;
            initializeMcqOptions(mcqOptionCount);
        }

        // Remove MCQ option
        function removeMcqOption() {
            if (mcqOptionCount <= 2) {
                toast.error('Minimum 2 options required');
                return;
            }
            mcqOptionCount--;
            initializeMcqOptions(mcqOptionCount);
        }

        // Add Poll option
        function addPollOption() {
            if (pollOptionCount >= 26) {
                toast.error('Maximum 26 options allowed');
                return;
            }
            pollOptionCount++;
            initializePollOptions(pollOptionCount);
        }

        // Remove Poll option
        function removePollOption() {
            if (pollOptionCount <= 2) {
                toast.error('Minimum 2 options required');
                return;
            }
            pollOptionCount--;
            initializePollOptions(pollOptionCount);
        }

        // Initialize Matching pairs with specified count
        function initializeMatchingPairs(count) {
            matchingPairCount = count;
            const container = document.getElementById('matchingPairsContainer');

            // Save existing values
            const existingValues = {};
            for (let i = 1; i <= 10; i++) {
                const leftInput = document.getElementById(`match${i}Left`);
                const rightInput = document.getElementById(`match${i}Right`);
                if (leftInput) existingValues[`${i}Left`] = leftInput.value;
                if (rightInput) existingValues[`${i}Right`] = rightInput.value;
            }

            container.innerHTML = '';

            for (let i = 0; i < count; i++) {
                const num = i + 1;
                const leftInput = document.createElement('input');
                leftInput.type = 'text';
                leftInput.id = `match${num}Left`;
                leftInput.placeholder = `Item ${num}`;
                leftInput.value = existingValues[`${num}Left`] || '';
                leftInput.style.width = '100%';

                const rightInput = document.createElement('input');
                rightInput.type = 'text';
                rightInput.id = `match${num}Right`;
                rightInput.placeholder = `Match ${num}`;
                rightInput.value = existingValues[`${num}Right`] || '';
                rightInput.style.width = '100%';

                container.appendChild(leftInput);
                container.appendChild(rightInput);
            }
        }

        // Add Matching pair
        function addMatchingPair() {
            if (matchingPairCount >= 10) {
                toast.error('Maximum 10 pairs allowed');
                return;
            }
            matchingPairCount++;
            initializeMatchingPairs(matchingPairCount);
        }

        // Remove Matching pair
        function removeMatchingPair() {
            if (matchingPairCount <= 2) {
                toast.error('Minimum 2 pairs required');
                return;
            }
            matchingPairCount--;
            initializeMatchingPairs(matchingPairCount);
        }

        // Initialize Ordering items with specified count
        function initializeOrderingItems(count) {
            orderingItemCount = count;
            const container = document.getElementById('orderingItemsContainer');

            // Save existing values
            const existingValues = {};
            for (let i = 1; i <= 10; i++) {
                const input = document.getElementById(`order${i}`);
                if (input) existingValues[i] = input.value;
            }

            container.innerHTML = '';

            for (let i = 0; i < count; i++) {
                const num = i + 1;
                const input = document.createElement('input');
                input.type = 'text';
                input.id = `order${num}`;
                input.placeholder = `${getOrdinal(num)} item`;
                input.value = existingValues[num] || '';
                input.style.width = '100%';
                container.appendChild(input);
            }
        }

        // Add Ordering item
        function addOrderingItem() {
            if (orderingItemCount >= 10) {
                toast.error('Maximum 10 items allowed');
                return;
            }
            orderingItemCount++;
            initializeOrderingItems(orderingItemCount);
        }

        // Remove Ordering item
        function removeOrderingItem() {
            if (orderingItemCount <= 2) {
                toast.error('Minimum 2 items required');
                return;
            }
            orderingItemCount--;
            initializeOrderingItems(orderingItemCount);
        }

        // Helper function to get ordinal suffix
        function getOrdinal(num) {
            const suffixes = ['th', 'st', 'nd', 'rd'];
            const value = num % 100;
            return num + (suffixes[(value - 20) % 10] || suffixes[value] || suffixes[0]);
        }

        async function loadSavedSettings() {
            try {
                // Load settings from backend API instead of localStorage
                const response = await fetch('https://api-modular.intellaclick.com/api/users/session-settings', {
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    }
                });

                if (response.ok) {
                    const data = await response.json();
                    const settings = data.settings;

                    // Apply saved settings to checkboxes
                    if (settings.allowAnonymous !== undefined) {
                        document.getElementById('allowAnonymous').checked = settings.allowAnonymous;
                    }
                    if (settings.openToAll !== undefined) {
                        document.getElementById('openToAll').checked = settings.openToAll;
                    }
                    if (settings.allowAnswerChange !== undefined) {
                        document.getElementById('allowAnswerChange').checked = settings.allowAnswerChange;
                    }
                    if (settings.showCorrectAnswer !== undefined) {
                        document.getElementById('showCorrectAnswer').checked = settings.showCorrectAnswer;
                    }
                    if (settings.enableGamification !== undefined) {
                        document.getElementById('enableGamification').checked = settings.enableGamification;
                    }
                    if (settings.autoSaveQuestions !== undefined) {
                        document.getElementById('autoSaveQuestions').checked = settings.autoSaveQuestions;
                    }

                    logger.debug('‚úÖ Loaded saved session settings from backend:', settings);
                } else {
                    logger.debug('No saved settings found, using defaults');
                }
            } catch (error) {
                logger.error('Error loading saved settings:', error);
                // Don't show error to user - just use defaults if loading fails
            }
        }

        async function loadClassInfo() {
            try {
                const data = await classesAPI.getById(classId);
                classData = data.class || data;

                document.getElementById('classInfo').innerHTML = `
                    <strong>${classData.name}</strong> - ${classData.code} ${classData.section ? '(' + classData.section + ')' : ''}
                `;

                // Set default session name
                const now = new Date();
                const dateStr = now.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                const timeStr = now.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
                document.getElementById('sessionName').value = `${classData.name} Session - ${dateStr} ${timeStr}`;
            } catch (error) {
                logger.error('Error loading class:', error);
                toast.error('Failed to load class information');
            }
        }

        function selectSessionType(type) {
            logger.debug('=== selectSessionType called ===');
            logger.debug('type:', type);
            selectedType = type;

            // Clear quick poll questions when switching session type
            if (type !== 'quick') {
                quickPollQuestions = [];
            } else {
                // Check if there are saved questions to load
                const fromSavedSet = sessionStorage.getItem('fromSavedSet');
                const pendingQuestions = sessionStorage.getItem('pendingQuestions');

                logger.debug('fromSavedSet:', fromSavedSet);
                logger.debug('pendingQuestions:', pendingQuestions ? `${pendingQuestions.length} chars` : 'null');

                if (fromSavedSet === 'true' && pendingQuestions) {
                    try {
                        quickPollQuestions = JSON.parse(pendingQuestions);
                        logger.debug('‚úÖ Loaded questions:', quickPollQuestions.length);
                        sessionStorage.removeItem('fromSavedSet'); // Clear flag
                        sessionStorage.removeItem('pendingQuestions'); // Also clear questions
                        toast.success(`Loaded ${quickPollQuestions.length} questions from saved set`);
                    } catch (e) {
                        logger.error('‚ùå Error loading saved questions:', e);
                    }
                } else {
                    logger.debug('No pending questions found');
                }

                renderQuestionsList(); // Show existing questions if any
            }

            // Update UI
            document.querySelectorAll('.option-card').forEach(card => {
                card.classList.remove('selected');
            });
            document.getElementById(type + 'Option').classList.add('selected');

            // Show configuration section
            document.getElementById('sessionConfig').style.display = 'block';

            // Show/hide specific configs
            document.getElementById('quickPollConfig').style.display = type === 'quick' ? 'block' : 'none';
            document.getElementById('quizConfig').style.display = type === 'quiz' ? 'block' : 'none';
            document.getElementById('desktopInstructions').style.display = type === 'desktop' ? 'block' : 'none';

            // Show/hide session settings based on type
            const showSettings = type !== 'desktop';
            document.getElementById('sessionSettings').style.display = showSettings ? 'block' : 'none';
            document.getElementById('sessionOptions').style.display = showSettings ? 'block' : 'none';
            document.getElementById('sessionName').parentElement.style.display = showSettings ? 'block' : 'none';

            // Update start button
            document.getElementById('startButton').style.display = type === 'desktop' ? 'none' : 'inline-block';

            if (type === 'quiz') {
                loadQuizzes();
            } else if (type === 'desktop') {
                showDesktopInstructions();
            }

            // Set default session name with timestamp to ensure uniqueness
            const now = new Date();
            const dateStr = now.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
            const timeStr = now.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
            document.getElementById('sessionName').value = `${classData.name} Session - ${dateStr} ${timeStr}`;
        }

        async function loadQuizzes() {
            try {
                const response = await fetch('https://api-modular.intellaclick.com/api/quizzes', {
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    }
                });

                const data = await response.json();
                const select = document.getElementById('quizSelect');
                const noQuizzesMessage = document.getElementById('noQuizzesMessage');

                if (data.success && data.quizzes && data.quizzes.length > 0) {
                    // Populate dropdown with quizzes
                    select.innerHTML = '<option value="">Select a quiz...</option>' +
                        data.quizzes.map(quiz =>
                            `<option value="${quiz._id}">${quiz.title} (${quiz.questionCount || 0} questions)</option>`
                        ).join('');
                    noQuizzesMessage.style.display = 'none';
                } else {
                    // No quizzes found
                    select.innerHTML = '<option value="">No quizzes available</option>';
                    noQuizzesMessage.style.display = 'block';
                }
            } catch (error) {
                logger.error('Error loading quizzes:', error);
                const select = document.getElementById('quizSelect');
                select.innerHTML = '<option value="">Error loading quizzes</option>';
                toast.error('Failed to load quizzes');
            }
        }

        function showDesktopInstructions() {
            // Update the desktop instructions with class info
            document.getElementById('desktopClassName').textContent = classData.name;
            document.getElementById('desktopJoinCode').textContent = classData.joinCode || 'N/A';
        }
        
        function updateQuestionOptions() {
            const questionType = document.getElementById('questionType').value;

            // Hide all option divs
            document.getElementById('mcqOptions').style.display = 'none';
            document.getElementById('pollOptions').style.display = 'none';
            document.getElementById('tfOptions').style.display = 'none';
            document.getElementById('matchingOptions').style.display = 'none';
            document.getElementById('orderingOptions').style.display = 'none';
            document.getElementById('fillblankOptions').style.display = 'none';

            // Show the selected one
            switch(questionType) {
                case 'mcq':
                    document.getElementById('mcqOptions').style.display = 'block';
                    break;
                case 'poll':
                    document.getElementById('pollOptions').style.display = 'block';
                    break;
                case 'tf':
                    document.getElementById('tfOptions').style.display = 'block';
                    break;
                case 'matching':
                    document.getElementById('matchingOptions').style.display = 'block';
                    break;
                case 'ordering':
                    document.getElementById('orderingOptions').style.display = 'block';
                    break;
                case 'fillblank':
                    document.getElementById('fillblankOptions').style.display = 'block';
                    break;
            }
        }

        function addQuickPollQuestion() {
            const questionType = document.getElementById('questionType').value;
            const questionText = document.getElementById('questionText').value.trim();

            if (!questionText) {
                toast.error('Please enter a question');
                return;
            }

            // Read timeLimit from the duration input
            const timeLimit = parseInt(document.getElementById('duration').value) || 60;

            let question = {
                text: questionText,
                type: questionType,
                timeLimit: timeLimit,
                points: 10  // Default points
            };

            // Validate and add question-specific data
            try {
                switch(questionType) {
                    case 'mcq':
                        const options = [];
                        const optionTexts = [];
                        let correctAnswer = null;

                        // Iterate through all MCQ options dynamically
                        for (let i = 0; i < mcqOptionCount; i++) {
                            const letter = String.fromCharCode(65 + i);
                            const optionInput = document.getElementById(`option${letter}`);
                            if (optionInput && optionInput.value.trim()) {
                                options.push(letter);
                                optionTexts.push(optionInput.value.trim());
                                const radioButton = document.querySelector(`input[name="correctAnswer"][value="${letter}"]`);
                                if (radioButton && radioButton.checked) {
                                    correctAnswer = letter;
                                }
                            }
                        }

                        if (options.length < 2) {
                            toast.error('Please provide at least 2 answer options');
                            return;
                        }

                        question.options = options;
                        question.optionTexts = optionTexts;
                        question.correctAnswer = correctAnswer;
                        break;

                    case 'poll':
                        const pollOptions = [];
                        const pollOptionTexts = [];

                        // Iterate through all poll options dynamically
                        for (let i = 0; i < pollOptionCount; i++) {
                            const letter = String.fromCharCode(65 + i);
                            const pollOptionInput = document.getElementById(`pollOption${letter}`);
                            if (pollOptionInput && pollOptionInput.value.trim()) {
                                pollOptions.push(letter);
                                pollOptionTexts.push(pollOptionInput.value.trim());
                            }
                        }

                        if (pollOptions.length < 2) {
                            toast.error('Please provide at least 2 poll options');
                            return;
                        }

                        question.options = pollOptions;
                        question.optionTexts = pollOptionTexts;
                        // Check if participation points should be awarded
                        const awardParticipationPoints = document.getElementById('pollParticipationPoints').checked;
                        question.awardParticipationPoints = awardParticipationPoints;
                        // No correctAnswer for polls (unless participation points enabled)
                        break;

                    case 'tf':
                        question.options = ['True', 'False'];
                        question.correctAnswer = document.querySelector('input[name="tfAnswer"]:checked').value;
                        break;

                    case 'matching':
                        const pairs = [];
                        for (let i = 1; i <= matchingPairCount; i++) {
                            const left = document.getElementById(`match${i}Left`).value.trim();
                            const right = document.getElementById(`match${i}Right`).value.trim();
                            if (left && right) {
                                pairs.push({ left, right });
                            }
                        }

                        if (pairs.length < 2) {
                            toast.error('Please provide at least 2 matching pairs');
                            return;
                        }

                        question.pairs = pairs;
                        logger.debug('üîç Created matching question with pairs:', { pairs, questionPairs: question.pairs });
                        break;

                    case 'ordering':
                        const items = [];
                        for (let i = 1; i <= orderingItemCount; i++) {
                            const item = document.getElementById(`order${i}`).value.trim();
                            if (item) {
                                items.push(item);
                            }
                        }

                        if (items.length < 2) {
                            toast.error('Please provide at least 2 items to order');
                            return;
                        }

                        question.correctOrder = items;
                        break;

                    case 'fillblank':
                        const blankAnswer = document.getElementById('blankAnswer').value.trim();
                        if (!blankAnswer) {
                            toast.error('Please provide the correct answer');
                            return;
                        }

                        if (!questionText.includes('[blank]')) {
                            toast.error('Please include [blank] in your question where the answer should go');
                            return;
                        }

                        question.correctAnswer = blankAnswer;
                        break;
                }

                // Check if we're editing or adding
                if (editingQuestionIndex !== null) {
                    // Update existing question
                    quickPollQuestions[editingQuestionIndex] = question;
                    logger.debug('‚úÖ Updated question at index:', editingQuestionIndex);
                    toast.success('Question updated successfully!');
                    editingQuestionIndex = null;
                    document.getElementById('addQuestionBtn').textContent = 'Add Question';
                    document.getElementById('cancelEditBtn').style.display = 'none';
                } else {
                    // Add new question to array
                    quickPollQuestions.push(question);
                    logger.debug('‚úÖ Added question to array:', { type: question.type, question, arrayLength: quickPollQuestions.length });
                    toast.success('Question added successfully!');
                }

                // Clear form
                clearQuestionForm();

                // Render questions list
                renderQuestionsList();

            } catch (error) {
                toast.error('Error adding question: ' + error.message);
            }
        }

        function clearQuestionForm() {
            document.getElementById('questionText').value = '';

            // Clear MCQ options (dynamic count)
            for (let i = 0; i < mcqOptionCount; i++) {
                const letter = String.fromCharCode(65 + i);
                const input = document.getElementById(`option${letter}`);
                if (input) input.value = '';
            }

            // Clear Poll options (dynamic count)
            for (let i = 0; i < pollOptionCount; i++) {
                const letter = String.fromCharCode(65 + i);
                const pollInput = document.getElementById(`pollOption${letter}`);
                if (pollInput) pollInput.value = '';
            }

            // Clear Matching pairs (dynamic count)
            for (let i = 1; i <= matchingPairCount; i++) {
                const matchLeft = document.getElementById(`match${i}Left`);
                const matchRight = document.getElementById(`match${i}Right`);
                if (matchLeft) matchLeft.value = '';
                if (matchRight) matchRight.value = '';
            }

            // Clear Ordering items (dynamic count)
            for (let i = 1; i <= orderingItemCount; i++) {
                const order = document.getElementById(`order${i}`);
                if (order) order.value = '';
            }

            const blankAnswer = document.getElementById('blankAnswer');
            if (blankAnswer) blankAnswer.value = '';
        }

        function removeQuickPollQuestion(index) {
            if (window.confirm('Remove this question?')) {
                quickPollQuestions.splice(index, 1);
                // If we're editing this question, cancel the edit
                if (editingQuestionIndex === index) {
                    cancelEdit();
                } else if (editingQuestionIndex !== null && editingQuestionIndex > index) {
                    // Adjust the editing index if we removed a question before it
                    editingQuestionIndex--;
                }
                renderQuestionsList();
            }
        }

        function editQuickPollQuestion(index) {
            const question = quickPollQuestions[index];
            console.log('üîß EDIT DEBUG - Starting edit for question:', question);

            // Set editing mode
            editingQuestionIndex = index;
            document.getElementById('addQuestionBtn').textContent = 'Update Question';
            document.getElementById('cancelEditBtn').style.display = 'inline-block';

            // Update question type selector
            document.getElementById('questionType').value = question.type;
            updateQuestionOptions();

            // Set question text
            document.getElementById('questionText').value = question.text;

            // Set points and time limit
            document.getElementById('duration').value = question.timeLimit || 60;
            document.getElementById('points').value = question.points || 10;

            // Wait for DOM to update after updateQuestionOptions(), then populate fields
            setTimeout(() => {
                console.log('üîß EDIT DEBUG - After first delay, question type:', question.type);

                // Populate type-specific fields
                switch (question.type) {
                    case 'mcq':
                        console.log('üîß MCQ - Setting count to:', question.options.length);
                        console.log('üîß MCQ - Option texts:', question.optionTexts);

                        // Set MCQ options count and initialize
                        mcqOptionCount = question.options.length;
                        initializeMcqOptions(mcqOptionCount);

                        // Wait for init, then set values
                        setTimeout(() => {
                            console.log('üîß MCQ - Populating options now...');
                            question.optionTexts.forEach((text, i) => {
                                const letter = String.fromCharCode(65 + i);
                                const input = document.getElementById(`option${letter}`);
                                console.log(`üîß MCQ - Option ${letter}: element=${!!input}, text="${text}"`);
                                if (input) {
                                    input.value = text;
                                    console.log(`üîß MCQ - Set value for ${letter}, now="${input.value}"`);
                                }
                            });
                            // Set correct answer
                            console.log('üîß MCQ - Correct answer:', question.correctAnswer);
                            const correctRadio = document.querySelector(`input[name="correctAnswer"][value="${question.correctAnswer}"]`);
                            console.log('üîß MCQ - Correct radio found:', !!correctRadio);
                            if (correctRadio) correctRadio.checked = true;
                        }, 50);
                        break;

                    case 'poll':
                        console.log('üîß POLL - Setting count to:', question.options.length);
                        console.log('üîß POLL - Option texts:', question.optionTexts);

                        // Set poll options count and initialize
                        pollOptionCount = question.options.length;
                        initializePollOptions(pollOptionCount);

                        // Wait for init, then set values
                        setTimeout(() => {
                            console.log('üîß POLL - Populating options now...');
                            question.optionTexts.forEach((text, i) => {
                                const letter = String.fromCharCode(65 + i);
                                const input = document.getElementById(`pollOption${letter}`);
                                console.log(`üîß POLL - Option ${letter}: element=${!!input}, text="${text}"`);
                                if (input) {
                                    input.value = text;
                                    console.log(`üîß POLL - Set value for ${letter}, now="${input.value}"`);
                                }
                            });
                            // Set participation points checkbox
                            document.getElementById('pollParticipationPoints').checked = question.awardParticipationPoints || false;
                            console.log('üîß POLL - Participation points set to:', question.awardParticipationPoints);
                        }, 50);
                        break;

                    case 'tf':
                        console.log('üîß TF - Correct answer:', question.correctAnswer);
                        // Set true/false answer
                        const tfRadio = document.querySelector(`input[name="tfAnswer"][value="${question.correctAnswer}"]`);
                        console.log('üîß TF - Radio found:', !!tfRadio);
                        if (tfRadio) tfRadio.checked = true;
                        break;

                    case 'matching':
                        console.log('üîß MATCHING - Pairs:', question.pairs);

                        // Set matching pairs count and initialize
                        matchingPairCount = question.pairs.length;
                        initializeMatchingPairs(matchingPairCount);

                        // Wait for init, then set values
                        setTimeout(() => {
                            console.log('üîß MATCHING - Populating pairs now...');
                            question.pairs.forEach((pair, i) => {
                                const leftInput = document.getElementById(`match${i + 1}Left`);
                                const rightInput = document.getElementById(`match${i + 1}Right`);
                                console.log(`üîß MATCHING - Pair ${i + 1}: left=${!!leftInput}, right=${!!rightInput}`, pair);
                                if (leftInput) leftInput.value = pair.left;
                                if (rightInput) rightInput.value = pair.right;
                            });
                        }, 50);
                        break;

                    case 'ordering':
                        console.log('üîß ORDERING - Items:', question.correctOrder);

                        // Set ordering items count and initialize
                        orderingItemCount = question.correctOrder.length;
                        initializeOrderingItems(orderingItemCount);

                        // Wait for init, then set values
                        setTimeout(() => {
                            console.log('üîß ORDERING - Populating items now...');
                            question.correctOrder.forEach((item, i) => {
                                const input = document.getElementById(`order${i + 1}`);
                                console.log(`üîß ORDERING - Item ${i + 1}: element=${!!input}, value="${item}"`);
                                if (input) input.value = item;
                            });
                        }, 50);
                        break;

                    case 'fillblank':
                        console.log('üîß FILLBLANK - Answer:', question.correctAnswer);
                        // Set fill-in-blank answer
                        const blankInput = document.getElementById('blankAnswer');
                        console.log('üîß FILLBLANK - Input found:', !!blankInput);
                        if (blankInput) blankInput.value = question.correctAnswer;
                        break;
                }

                // Scroll to question form
                document.getElementById('quickPollQuestionForm').scrollIntoView({ behavior: 'smooth' });
                toast.info('Editing question. Click "Update Question" when done.');
            }, 100);
        }

        function cancelEdit() {
            editingQuestionIndex = null;
            document.getElementById('addQuestionBtn').textContent = '+ Add This Question';
            document.getElementById('cancelEditBtn').style.display = 'none';
            clearQuestionForm();
            toast.info('Edit cancelled');
        }

        function renderQuestionsList() {
            const container = document.getElementById('questionsList');

            if (quickPollQuestions.length === 0) {
                container.innerHTML = '<p style="color: var(--text-secondary); font-size: 14px;">No questions added yet.</p>';
                return;
            }

            container.innerHTML = `
                <div style="margin-bottom: 12px;">
                    <strong>${quickPollQuestions.length} Question(s) Added:</strong>
                </div>
                ${quickPollQuestions.map((q, index) => `
                    <div style="background-color: #F9FAFB; padding: 12px; border-radius: 8px; margin-bottom: 8px; display: flex; justify-content: space-between; align-items: start;">
                        <div style="flex: 1;">
                            <div style="font-weight: 500; margin-bottom: 4px;">Q${index + 1}: ${q.text}</div>
                            <div style="font-size: 12px; color: var(--text-secondary);">Type: ${q.type.toUpperCase()}${q.awardParticipationPoints ? ' | Participation Points: ‚úì' : ''}</div>
                        </div>
                        <div style="display: flex; gap: 8px;">
                            <button type="button" class="btn btn-secondary btn-small" onclick="editQuickPollQuestion(${index})">Edit</button>
                            <button type="button" class="btn btn-danger btn-small" onclick="removeQuickPollQuestion(${index})">Remove</button>
                        </div>
                    </div>
                `).join('')}
            `;
        }

        async function handleStartSession(e) {
            e.preventDefault();
            
            if (!selectedType) {
                toast.error('Please select a session type');
                return;
            }
            
            if (selectedType === 'desktop') {
                // Desktop sessions are started from the desktop app
                return;
            }
            
            // Get custom session code or generate a random one
            const customCode = document.getElementById('customSessionCode').value.trim();
            const sessionCode = customCode || Math.random().toString(36).substring(2, 8).toUpperCase();

            const sessionData = {
                sessionCode: sessionCode,
                title: document.getElementById('sessionName').value,
                description: `${selectedType === 'quick' ? 'Quick Poll' : 'Quiz Session'} for ${classData.name}`,
                requireLogin: !document.getElementById('allowAnonymous').checked, // Invert anonymous flag
                classId: classId, // Add class ID for enrollment checking
                restrictToEnrolled: !document.getElementById('openToAll').checked, // Restrict by default
                gamification: { enabled: document.getElementById('enableGamification').checked }, // Gamification settings object
                allowAnswerChange: document.getElementById('allowAnswerChange').checked, // Allow students to change answer
                showCorrectAnswer: document.getElementById('showCorrectAnswer').checked // Show correct answer when question ends
            };

            logger.debug('=== CREATING SESSION WITH SETTINGS ===');
            logger.debug('showCorrectAnswer checkbox value:', document.getElementById('showCorrectAnswer').checked);
            logger.debug('Session data being sent:', sessionData);
            
            if (selectedType === 'quick') {
                // Check if there are questions added
                if (quickPollQuestions.length === 0) {
                    toast.error('Please add at least one question to the quick poll');
                    return;
                }

                // Use all questions from the array
                sessionData.questions = quickPollQuestions;
            } else if (selectedType === 'quiz') {
                // Get selected quiz
                const quizId = document.getElementById('quizSelect').value;
                if (!quizId) {
                    toast.error('Please select a quiz');
                    return;
                }

                // Fetch quiz data
                try {
                    const quizResponse = await fetch(`https://api-modular.intellaclick.com/api/quizzes/${quizId}`, {
                        headers: {
                            'Authorization': `Bearer ${localStorage.getItem('token')}`
                        }
                    });

                    if (!quizResponse.ok) {
                        throw new Error('Failed to load quiz');
                    }

                    const quizData = await quizResponse.json();
                    const quiz = quizData.quiz || quizData;

                    // Transform quiz questions to session format
                    const quizQuestions = (quiz.questions || []).map(q => {
                        const snapshot = q.questionSnapshot || {};
                        // Check BOTH questionType (new schema) and type (old data) for backwards compatibility
                        const questionType = snapshot.questionType || snapshot.type || 'mcq';

                        return {
                            text: snapshot.questionText || '',
                            type: questionType,
                            timeLimit: 60, // Default time limit
                            points: q.points || 10,
                            options: snapshot.options,
                            correctAnswer: snapshot.correctAnswer,
                            pairs: snapshot.pairs,
                            correctOrder: snapshot.correctOrder,
                            optionTexts: snapshot.options // For MCQ
                        };
                    });

                    // Add quiz questions to session
                    sessionData.questions = quizQuestions;
                    sessionData.quizId = quizId;
                    sessionData.quizTitle = quiz.title;

                    if (sessionData.questions.length === 0) {
                        toast.error('Selected quiz has no questions');
                        return;
                    }
                } catch (error) {
                    logger.error('Error loading quiz:', error);
                    toast.error('Failed to load quiz data');
                    return;
                }
            }
            
            try {
                const result = await sessions.create(sessionData);
                const session = result.session || result;

                // Save session settings to backend for next time (don't wait for this)
                const sessionSettings = {
                    allowAnonymous: document.getElementById('allowAnonymous').checked,
                    openToAll: document.getElementById('openToAll').checked,
                    allowAnswerChange: document.getElementById('allowAnswerChange').checked,
                    showCorrectAnswer: document.getElementById('showCorrectAnswer').checked,
                    enableGamification: document.getElementById('enableGamification').checked,
                    autoSaveQuestions: document.getElementById('autoSaveQuestions').checked
                };

                // Save to backend (async, don't wait)
                fetch('https://api-modular.intellaclick.com/api/users/session-settings', {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    },
                    body: JSON.stringify(sessionSettings)
                }).then(() => {
                    logger.debug('‚úÖ Saved session settings to backend for next time');
                }).catch(err => {
                    logger.error('Failed to save settings (non-critical):', err);
                });

                // Show session code in toast for instructor to share
                toast.success(`Session created! Code: ${session.sessionCode || sessionCode}`);

                // Store all questions in sessionStorage for the session page to use
                if (sessionData.questions && sessionData.questions.length > 0) {
                    logger.debug('üì¶ Storing questions in sessionStorage:', sessionData.questions);
                    sessionStorage.setItem('pendingQuestions', JSON.stringify(sessionData.questions));
                    sessionStorage.setItem('currentQuestionIndex', '0'); // Start with first question

                    // Verify what was stored
                    const stored = JSON.parse(sessionStorage.getItem('pendingQuestions'));
                    logger.debug('‚úÖ Verified stored questions:', stored);
                }

                // AUTO-SAVE: Save questions for reuse (only if checkbox is checked)
                const shouldAutoSave = document.getElementById('autoSaveQuestions').checked;
                logger.debug('Auto-save checkbox state:', shouldAutoSave);

                if (shouldAutoSave && sessionData.questions && sessionData.questions.length > 0) {
                    // Don't wait for auto-save to complete - let it run in background
                    logger.debug('Auto-saving questions because checkbox is checked');
                    autoSaveQuestions(sessionData.title, sessionData.questions);
                } else if (!shouldAutoSave) {
                    logger.debug('‚è≠Ô∏è Skipping auto-save - user unchecked the box');
                }

                // Redirect to session management page with session info
                // Increased delay to give more time to see console logs
                setTimeout(() => {
                    logger.debug('=== REDIRECTING NOW ===');
                    window.location.href = `session.html?id=${session.id || session._id}&code=${session.sessionCode || sessionCode}&type=${selectedType}`;
                }, 5000); // Give 5 seconds to see auto-save logs
                
            } catch (error) {
                logger.error('Error creating session:', error);
                toast.error(error.message || 'Failed to create session');
            }
        }

        function cancelSession() {
            if (window.confirm('Are you sure you want to cancel?')) {
                window.location.href = 'classes.html';
            }
        }


        function goToSavedQuestions() {
            // Save current URL so we can return here
            const returnUrl = window.location.href;
            sessionStorage.setItem('createSessionUrl', returnUrl);

            logger.debug('Navigating to saved questions, returnUrl:', returnUrl);

            // Navigate with returnUrl parameter
            window.location.href = `saved-questions.html?returnUrl=${encodeURIComponent(returnUrl)}`;
        }

        // Legacy function name for compatibility
        function loadSavedQuestions() {
            goToSavedQuestions();
        }

        function insertBlank() {
            const textarea = document.getElementById('questionText');
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            const text = textarea.value;

            // Insert [blank] at cursor position
            const newText = text.substring(0, start) + '[blank]' + text.substring(end);
            textarea.value = newText;

            // Move cursor after [blank]
            textarea.selectionStart = textarea.selectionEnd = start + 7;
            textarea.focus();
        }

        async function autoSaveQuestions(sessionName, questions) {
            logger.debug('=== AUTO-SAVE CALLED ===');
            logger.debug('Session name:', sessionName);
            logger.debug('Questions array:', questions);
            logger.debug('Questions length:', questions?.length);

            if (!questions || questions.length === 0) {
                logger.debug('‚ùå No questions to save - skipping auto-save');
                return;
            }

            const token = localStorage.getItem('token');
            if (!token) {
                logger.warn('‚ö†Ô∏è No authentication token - skipping auto-save (silent)');
                return;
            }

            logger.debug(`üîÑ Auto-saving "${sessionName}" with ${questions.length} questions to cloud...`);

            const payload = {
                name: sessionName,
                questions: questions,
                classId: null
            };
            logger.debug('Payload being sent:', JSON.stringify(payload, null, 2));

            try {
                const response = await fetch('https://api-modular.intellaclick.com/api/question-sets', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify(payload)
                });

                logger.debug('Response status:', response.status);

                if (!response.ok) {
                    const errorData = await response.json();
                    logger.error('‚ùå Cloud API save failed:', errorData);
                    logger.error('Response status:', response.status);
                    logger.warn('‚ö†Ô∏è Question set auto-save failed, but session will continue');
                    return;
                }

                const data = await response.json();
                logger.debug('‚úÖ Question set auto-saved to cloud successfully:', data);
            } catch (error) {
                logger.error('‚ùå Error auto-saving question set:', error);
                logger.error('Error stack:', error.stack);
                logger.warn('‚ö†Ô∏è Question set auto-save failed, but session will continue');
            }
        }

        // Expose functions to window object for onclick handlers
        window.selectSessionType = selectSessionType;
        window.goToSavedQuestions = goToSavedQuestions;
        window.insertBlank = insertBlank;
        window.updateQuestionOptions = updateQuestionOptions;
        window.addQuickPollQuestion = addQuickPollQuestion;
        window.cancelSession = cancelSession;
        window.removeQuickPollQuestion = removeQuickPollQuestion;
        window.editQuickPollQuestion = editQuickPollQuestion;
        window.cancelEdit = cancelEdit;
        window.addMcqOption = addMcqOption;
        window.removeMcqOption = removeMcqOption;
        window.addPollOption = addPollOption;
        window.removePollOption = removePollOption;
        window.addMatchingPair = addMatchingPair;
        window.removeMatchingPair = removeMatchingPair;
        window.addOrderingItem = addOrderingItem;
        window.removeOrderingItem = removeOrderingItem;
    </script>
</body>
</html>