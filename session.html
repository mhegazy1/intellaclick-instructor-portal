<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Session Management - IntellaClick</title>
    <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.1/build/qrcode.min.js"></script>
    <!-- Modular CSS -->
    <link rel="stylesheet" href="styles/common.css">
    <link rel="stylesheet" href="styles/session.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Session Management</h1>
            <div class="session-info">
                <div class="info-item">
                    <span class="info-label">Session Code</span>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span class="session-code" id="sessionCode">Loading...</span>
                        <button class="btn btn-secondary" onclick="copySessionCode()" style="padding: 4px 8px; font-size: 12px;">Copy</button>
                    </div>
                </div>
                <div class="info-item">
                    <span class="info-label">Status</span>
                    <span class="status-badge status-waiting" id="sessionStatus">Waiting</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Participants</span>
                    <span class="info-value" id="participantCount">0</span>
                </div>
            </div>
            <div class="join-url" id="joinUrl">
                Students can join at: https://join.intellaclick.com/session/XXXXX
            </div>
            <div class="qr-container">
                <div class="qr-code" id="qrcode"></div>
                <div class="qr-info">
                    <h3>Scan to Join</h3>
                    <p>Students can scan this QR code with their phone to join the session instantly. The code contains the direct link to join this session.</p>
                </div>
            </div>
        </div>

        <div class="section" id="questionSection">
            <h2>Question Management</h2>
            
            <!-- Question Queue -->
            <div id="questionQueue" style="margin-bottom: 20px;">
                <h3 style="font-size: 16px; margin-bottom: 12px;">Question Queue</h3>
                <div id="queueList" style="background-color: var(--background); padding: 12px; border-radius: 8px; min-height: 60px;">
                    <p style="color: var(--text-secondary); font-size: 14px;">No questions in queue. Create a new question or import from a quiz.</p>
                </div>
            </div>

            <!-- Current Question Display -->
            <div id="currentQuestionSection" style="display: none; margin-bottom: 20px;">
                <h3 style="font-size: 16px; margin-bottom: 12px;">Current Question</h3>
                <div style="background-color: #EFF6FF; padding: 16px; border-radius: 8px;">
                    <h4 id="questionText" style="margin-bottom: 12px;"></h4>
                    <div id="questionOptions"></div>
                </div>
            </div>

            <div class="control-buttons">
                <button class="btn btn-primary" onclick="openDisplayView()" style="font-size: 1rem; font-weight: 600;">
                    <svg width="20" height="20" fill="currentColor" style="margin-right: 6px;">
                        <path d="M0 1.5A1.5 1.5 0 0 1 1.5 0h13A1.5 1.5 0 0 1 16 1.5v13a1.5 1.5 0 0 1-1.5 1.5h-13A1.5 1.5 0 0 1 0 14.5v-13zM1.5 1a.5.5 0 0 0-.5.5v13a.5.5 0 0 0 .5.5h13a.5.5 0 0 0 .5-.5v-13a.5.5 0 0 0-.5-.5h-13z"/>
                        <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
                    </svg>
                    üñ•Ô∏è Open Display View
                </button>
                <button class="btn btn-primary" onclick="showQuestionModal()">
                    <svg width="16" height="16" fill="currentColor" style="margin-right: 4px;">
                        <path d="M8 2a.5.5 0 0 1 .5.5v5h5a.5.5 0 0 1 0 1h-5v5a.5.5 0 0 1-1 0v-5h-5a.5.5 0 0 1 0-1h5v-5A.5.5 0 0 1 8 2Z"/>
                    </svg>
                    Create Question
                </button>
                <button class="btn btn-secondary" onclick="showImportModal()">
                    <svg width="16" height="16" fill="currentColor" style="margin-right: 4px;">
                        <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/>
                        <path d="M7.646 1.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 2.707V11.5a.5.5 0 0 1-1 0V2.707L5.354 4.854a.5.5 0 1 1-.708-.708l3-3z"/>
                    </svg>
                    Import Quiz
                </button>
                <button class="btn btn-success" onclick="sendNextQuestion()" disabled id="sendBtn">Next Question</button>
                <button class="btn btn-secondary" onclick="stopQuestion()" disabled id="stopBtn">Stop Question</button>
                <button class="btn btn-success" onclick="showResults()" id="resultsBtn">Show Results</button>
            </div>
        </div>

        <div class="section">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                <h2 style="margin: 0;">Participants</h2>
                <button class="btn btn-secondary" onclick="loadSession()" style="padding: 6px 12px; font-size: 12px;">
                    Refresh
                </button>
            </div>
            <div id="participantsList" class="participants-grid">
                <p style="color: var(--text-secondary);">No participants yet. Share the session code for students to join.</p>
            </div>
        </div>

        <div class="section" id="responsesSection" style="display: none;">
            <h2>Responses</h2>
            <div class="response-chart" id="responseChart">
                Response data will appear here
            </div>
        </div>

        <div class="control-buttons">
            <button class="btn btn-danger" onclick="endSession()">End Session</button>
            <a href="classes.html" class="btn btn-secondary">Back to Classes</a>
        </div>
    </div>


    <!-- Create Question Modal -->
    <div id="questionModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="close" onclick="closeQuestionModal()">&times;</span>
                <h2>Create Quick Question</h2>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="modalQuestionText">Question</label>
                    <textarea id="modalQuestionText" rows="3" placeholder="Enter your question here..."></textarea>
                </div>
                
                <div class="form-group">
                    <label for="modalQuestionType">Question Type</label>
                    <select id="modalQuestionType" onchange="updateModalOptions()">
                        <option value="mcq">Multiple Choice</option>
                        <option value="poll">Poll Question (No Correct Answer)</option>
                        <option value="tf">True/False</option>
                        <option value="matching">Matching</option>
                        <option value="ordering">Put in Order</option>
                        <option value="fillblank">Fill in the Blank</option>
                    </select>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px;">
                    <div class="form-group" style="margin-bottom: 0;">
                        <label for="modalTimeLimit">Time Limit (seconds)</label>
                        <input type="number" id="modalTimeLimit" value="60" min="10" max="300">
                    </div>
                    <div class="form-group" style="margin-bottom: 0;">
                        <label for="modalPoints">Points</label>
                        <input type="number" id="modalPoints" value="10" min="1" max="100">
                    </div>
                </div>

                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; user-select: none;">
                        <input type="checkbox" id="modalAwardParticipation" style="width: 20px; height: 20px; cursor: pointer;">
                        <span>Award points for participation (even if answer is wrong)</span>
                    </label>
                </div>

                <div id="modalQuestionOptions">
                    <!-- Options will be dynamically inserted based on question type -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeQuestionModal()">Cancel</button>
                <button class="btn btn-primary" onclick="addQuestionToQueue()">Add to Queue</button>
            </div>
        </div>
    </div>

    <!-- Import Quiz Modal -->
    <div id="importModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="close" onclick="closeImportModal()">&times;</span>
                <h2>Import Quiz Questions</h2>
            </div>
            <div class="modal-body">
                <p style="margin-bottom: 16px;">Select a quiz to import its questions:</p>
                <div class="quiz-list" id="quizList">
                    <p style="color: var(--text-secondary); text-align: center; padding: 20px;">Loading quizzes...</p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeImportModal()">Cancel</button>
                <button class="btn btn-primary" onclick="importSelectedQuiz()" disabled id="importBtn">Import Selected</button>
            </div>
        </div>
    </div>

    <script type="module">
        // === Modular Imports ===
        import { sessions, gamifiedSessions } from './utils/api.js';
        import toast from './utils/toast.js';
        import logger from './utils/logger.js';
        import loading from './utils/loading.js';

        let sessionId;
        let sessionCode;
        let sessionData;
        let classId;
        let questionQueue = [];
        let currentQuestionIndex = -1;
        let pollInterval;
        let selectedQuizId = null;

        // Question defaults (loaded from backend)
        let questionDefaults = {
            defaultTimeLimit: 60,
            defaultPoints: 10,
            defaultAwardParticipation: false,
            defaultShowCorrectAnswer: true,
            defaultAllowAnswerChange: true
        };

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            const urlParams = new URLSearchParams(window.location.search);
            sessionId = urlParams.get('id');
            sessionCode = urlParams.get('code');
            const sessionType = urlParams.get('type');
            
            if (!sessionId || !sessionCode) {
                toast.error('Invalid session parameters');
                setTimeout(() => window.location.href = 'classes.html', 2000);
                return;
            }

            // Check for pending question from create-session page
            // Load multiple questions from sessionStorage (new format)
            const questionsData = sessionStorage.getItem('pendingQuestions');
            if (questionsData) {
                const questions = JSON.parse(questionsData);
                questionQueue.push(...questions); // Add all questions to queue
                sessionStorage.removeItem('pendingQuestions');
                sessionStorage.removeItem('currentQuestionIndex');
                updateQueueDisplay();
            } else {
                // Fallback to single question format (legacy support)
                const questionData = sessionStorage.getItem('pendingQuestion');
                if (questionData) {
                    const question = JSON.parse(questionData);
                    questionQueue.push(question);
                    sessionStorage.removeItem('pendingQuestion');
                    updateQueueDisplay();
                }
            }

            // NEW: Try to restore queue from sessionStorage first (for same browser session)
            if (questionQueue.length === 0) {
                const savedQueue = sessionStorage.getItem('questionQueue_' + sessionCode);
                const savedIndex = sessionStorage.getItem('questionIndex_' + sessionCode);

                if (savedQueue) {
                    console.log('[Session] Restoring queue from sessionStorage');
                    questionQueue = JSON.parse(savedQueue);
                    currentQuestionIndex = savedIndex ? parseInt(savedIndex) : -1;
                    updateQueueDisplay();
                }
            }

            // NEW: If still empty, try to restore from backend (for crashed/resumed sessions)
            if (questionQueue.length === 0) {
                console.log('[Session] Attempting to restore queue from backend');
                restoreQueueFromBackend();
            }

            checkAuth();
            loadSession();
            loadQuestionDefaults(); // Load question defaults from backend
            startPolling();
        });

        function checkAuth() {
            const token = localStorage.getItem('token');
            if (!token) {
                window.location.href = '/login.html';
            }
        }

        async function loadSession() {
            try {
                const response = await fetch(`https://api-modular.intellaclick.com/api/sessions/code/${sessionCode}`, {
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    }
                });

                if (!response.ok) throw new Error('Failed to load session');

                const data = await response.json();
                sessionData = data.session;
                classId = sessionData.classId; // Get classId from session data
                
                logger.debug('Session loaded:', {
                    sessionId: sessionId,
                    sessionCode: sessionCode,
                    sessionData: sessionData,
                    hasCurrentQuestion: !!sessionData.currentQuestion
                });
                
                updateSessionDisplay();
            } catch (error) {
                logger.error('Error loading session:', error);
                toast.error('Failed to load session');
            }
        }

        // NEW: Restore question queue from backend (for crashed/resumed sessions)
        async function restoreQueueFromBackend() {
            try {
                const response = await fetch(`https://api-modular.intellaclick.com/api/sessions/${sessionId}`, {
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    }
                });

                if (!response.ok) {
                    console.error('[Session] Failed to fetch session data for queue restoration');
                    return;
                }

                const data = await response.json();

                if (data.success && data.session.questionQueue && data.session.questionQueue.length > 0) {
                    questionQueue = data.session.questionQueue;
                    currentQuestionIndex = data.session.currentQuestionIndex ?? -1;

                    console.log('[Session] Queue restored from backend:', {
                        queueLength: questionQueue.length,
                        currentIndex: currentQuestionIndex
                    });

                    updateQueueDisplay();
                    toast.success(`Restored ${questionQueue.length} questions from previous session`);
                } else {
                    console.log('[Session] No saved queue found in backend');
                }
            } catch (error) {
                console.error('[Session] Error restoring queue from backend:', error);
            }
        }

        // NEW: Save question queue to backend (for crash recovery)
        async function saveQueueToBackend() {
            try {
                const response = await fetch(`https://api-modular.intellaclick.com/api/sessions/${sessionId}/question-queue`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    },
                    body: JSON.stringify({
                        questionQueue: questionQueue,
                        currentQuestionIndex: currentQuestionIndex
                    })
                });

                if (!response.ok) {
                    console.error('[Session] Failed to save queue to backend');
                    return;
                }

                console.log('[Session] Queue saved to backend successfully');
            } catch (error) {
                console.error('[Session] Error saving queue to backend:', error);
                // Don't show error to user - this is a background operation
            }
        }

        // Load question defaults from backend
        async function loadQuestionDefaults() {
            try {
                const response = await fetch('https://api-modular.intellaclick.com/api/users/question-defaults', {
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    }
                });

                if (response.ok) {
                    const data = await response.json();
                    questionDefaults = data.defaults || questionDefaults;

                    // Pre-fill modal inputs with defaults
                    document.getElementById('modalTimeLimit').value = questionDefaults.defaultTimeLimit;
                    document.getElementById('modalPoints').value = questionDefaults.defaultPoints;
                    document.getElementById('modalAwardParticipation').checked = questionDefaults.defaultAwardParticipation;

                    logger.debug('‚úÖ Loaded question defaults:', questionDefaults);
                } else {
                    logger.debug('No saved question defaults found, using system defaults');
                }
            } catch (error) {
                logger.error('Error loading question defaults:', error);
            }
        }

        function updateSessionDisplay() {
            document.getElementById('sessionCode').textContent = sessionData.sessionCode;
            document.getElementById('participantCount').textContent = sessionData.participantCount || 0;
            
            const joinUrl = `https://join.intellaclick.com/session/${sessionData.sessionCode}`;
            document.getElementById('joinUrl').innerHTML = `
                <strong>Students can join at:</strong><br>
                <div style="display: flex; align-items: center; gap: 12px; margin: 8px 0;">
                    <span style="font-size: 16px; user-select: all; flex: 1;">${joinUrl}</span>
                    <button class="btn btn-secondary" onclick="copyJoinUrl('${joinUrl}')" style="padding: 6px 12px; font-size: 12px;">
                        Copy Link
                    </button>
                </div>
                <small style="color: var(--text-secondary); margin-top: 4px; display: block;">
                    Session ID: ${sessionData.id || sessionData._id}<br>
                    ${sessionData.restrictToEnrolled === false ? 'Open to all students' : 'Restricted to enrolled students only'}
                </small>
            `;
            
            // Generate QR code
            generateQRCode(joinUrl);
            
            // Update status badge
            const statusEl = document.getElementById('sessionStatus');
            statusEl.textContent = sessionData.status.charAt(0).toUpperCase() + sessionData.status.slice(1);
            statusEl.className = `status-badge status-${sessionData.status}`;
            
            // Update button states
            if (sessionData.status === 'active' && sessionData.currentQuestion) {
                document.getElementById('stopBtn').disabled = false;
                document.getElementById('resultsBtn').disabled = false;
                displayCurrentQuestion(sessionData.currentQuestion);
            }
            
            // Update participants list
            updateParticipantsList();
        }
        
        function updateParticipantsList() {
            const participantsList = document.getElementById('participantsList');
            
            // Load detailed participant info if available
            fetch(`https://api-modular.intellaclick.com/api/sessions/${sessionId}/participants`, {
                headers: {
                    'Authorization': `Bearer ${localStorage.getItem('token')}`
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.participants && data.participants.length > 0) {
                    participantsList.innerHTML = '';
                    data.participants.forEach(p => {
                        const card = document.createElement('div');
                        card.className = 'participant-card';
                        card.innerHTML = `
                            <strong>${p.name || 'Anonymous'}</strong><br>
                            <small style="color: var(--text-secondary);">
                                Joined: ${new Date(p.joinedAt).toLocaleTimeString()}<br>
                                ${p.isEnrolled ? 'Enrolled Student' : 'Guest'}
                            </small>
                        `;
                        participantsList.appendChild(card);
                    });
                } else {
                    participantsList.innerHTML = '<p style="color: var(--text-secondary);">No participants yet. Share the session code for students to join.</p>';
                }
            })
            .catch(error => {
                logger.error('Error loading participants:', error);
            });
        }

        function generateQRCode(url) {
            const qrContainer = document.getElementById('qrcode');
            qrContainer.innerHTML = ''; // Clear existing QR code
            
            // Create a canvas element
            const canvas = document.createElement('canvas');
            
            QRCode.toCanvas(canvas, url, {
                width: 400,
                margin: 2,
                color: {
                    dark: '#000000',
                    light: '#FFFFFF'
                }
            }, function(error) {
                if (error) {
                    logger.error('QR Code generation error:', error);
                    qrContainer.innerHTML = '<p style="color: var(--text-secondary);">QR Code generation failed</p>';
                    return;
                }
                
                canvas.style.width = '200px';
                canvas.style.height = '200px';
                qrContainer.appendChild(canvas);
            });
        }

        // Question Queue Management
        function updateQueueDisplay() {
            const queueList = document.getElementById('queueList');

            // Save queue to sessionStorage for display view (immediate access)
            sessionStorage.setItem('questionQueue_' + sessionCode, JSON.stringify(questionQueue));
            sessionStorage.setItem('questionIndex_' + sessionCode, currentQuestionIndex.toString());

            // NEW: Save to backend (for crash recovery)
            saveQueueToBackend();

            if (questionQueue.length === 0) {
                queueList.innerHTML = '<p style="color: var(--text-secondary); font-size: 14px;">No questions in queue. Create a new question or import from a quiz.</p>';
                document.getElementById('sendBtn').disabled = true;
            } else {
                queueList.innerHTML = '';
                questionQueue.forEach((question, index) => {
                    const item = document.createElement('div');
                    item.className = 'question-item';
                    item.style.padding = '12px';
                    item.style.marginBottom = '8px';
                    item.style.border = '1px solid var(--border-color)';
                    item.style.borderRadius = '6px';
                    item.style.backgroundColor = 'var(--bg-primary)';

                    // Question header: number and text
                    const questionHeader = document.createElement('div');
                    questionHeader.style.display = 'flex';
                    questionHeader.style.alignItems = 'flex-start';
                    questionHeader.style.marginBottom = '10px';

                    const questionNumber = document.createElement('div');
                    questionNumber.style.fontWeight = 'bold';
                    questionNumber.style.marginRight = '8px';
                    questionNumber.style.minWidth = '24px';
                    questionNumber.style.color = 'var(--text-secondary)';
                    questionNumber.textContent = `${index + 1}.`;

                    const questionText = document.createElement('div');
                    questionText.style.flex = '1';
                    questionText.style.lineHeight = '1.4';
                    questionText.textContent = question.text || question.questionText;

                    questionHeader.appendChild(questionNumber);
                    questionHeader.appendChild(questionText);

                    // Settings and actions row
                    if (index > currentQuestionIndex) {
                        const settingsAndActions = document.createElement('div');
                        settingsAndActions.style.display = 'flex';
                        settingsAndActions.style.justifyContent = 'space-between';
                        settingsAndActions.style.alignItems = 'center';
                        settingsAndActions.style.paddingTop = '10px';
                        settingsAndActions.style.borderTop = '1px solid var(--border-color)';

                        // Settings section (left side) - Grid layout for perfect alignment
                        const settings = document.createElement('div');
                        settings.style.display = 'grid';
                        settings.style.gridTemplateColumns = 'auto auto auto';
                        settings.style.gap = '12px 20px';
                        settings.style.alignItems = 'center';
                        settings.style.fontSize = '13px';

                        // Time limit - Row 1
                        const timeLabel = document.createElement('span');
                        timeLabel.style.color = 'var(--text-secondary)';
                        timeLabel.style.textAlign = 'right';
                        timeLabel.style.minWidth = '50px';
                        timeLabel.textContent = 'Time:';

                        const timeInput = document.createElement('input');
                        timeInput.type = 'number';
                        timeInput.value = question.timeLimit || 60;
                        timeInput.min = 10;
                        timeInput.max = 300;
                        timeInput.style.width = '60px';
                        timeInput.style.padding = '4px 8px';
                        timeInput.style.border = '1px solid var(--border-color)';
                        timeInput.style.borderRadius = '4px';
                        timeInput.style.fontSize = '13px';
                        // Use both onchange (when focus lost) and onblur (when clicking away)
                        const updateTime = () => {
                            const newTime = parseInt(timeInput.value) || 60;
                            question.timeLimit = newTime;
                            console.log(`‚úèÔ∏è Updated question ${index + 1} time limit:`, newTime, 'Full question:', question);
                            // Save to sessionStorage so display view gets the updated value
                            sessionStorage.setItem('questionQueue_' + sessionCode, JSON.stringify(questionQueue));
                            saveQueueToBackend();
                        };
                        timeInput.onchange = updateTime;
                        timeInput.onblur = updateTime;

                        const timeUnit = document.createElement('span');
                        timeUnit.style.color = 'var(--text-secondary)';
                        timeUnit.textContent = 'sec';

                        // Points - Row 2
                        const pointsLabel = document.createElement('span');
                        pointsLabel.style.color = 'var(--text-secondary)';
                        pointsLabel.style.textAlign = 'right';
                        pointsLabel.style.minWidth = '50px';
                        pointsLabel.textContent = 'Points:';

                        const pointsInput = document.createElement('input');
                        pointsInput.type = 'number';
                        pointsInput.value = question.points || 10;
                        pointsInput.min = 1;
                        pointsInput.max = 100;
                        pointsInput.style.width = '60px';
                        pointsInput.style.padding = '4px 8px';
                        pointsInput.style.border = '1px solid var(--border-color)';
                        pointsInput.style.borderRadius = '4px';
                        pointsInput.style.fontSize = '13px';
                        // Use both onchange (when focus lost) and onblur (when clicking away)
                        const updatePoints = () => {
                            const newPoints = parseInt(pointsInput.value) || 10;
                            question.points = newPoints;
                            console.log(`‚úèÔ∏è Updated question ${index + 1} points:`, newPoints, 'Full question:', question);
                            // Save to sessionStorage so display view gets the updated value
                            sessionStorage.setItem('questionQueue_' + sessionCode, JSON.stringify(questionQueue));
                            saveQueueToBackend();
                        };
                        pointsInput.onchange = updatePoints;
                        pointsInput.onblur = updatePoints;

                        const pointsUnit = document.createElement('span');
                        pointsUnit.style.color = 'var(--text-secondary)';
                        pointsUnit.textContent = 'pts';

                        // Participation - Row 3
                        const participationLabel = document.createElement('span');
                        participationLabel.style.color = 'var(--text-secondary)';
                        participationLabel.style.textAlign = 'right';
                        participationLabel.style.minWidth = '50px';
                        participationLabel.textContent = 'Award:';

                        // Container to align checkbox with inputs above
                        const participationCheckContainer = document.createElement('div');
                        participationCheckContainer.style.width = '60px';
                        participationCheckContainer.style.display = 'flex';
                        participationCheckContainer.style.alignItems = 'center';
                        participationCheckContainer.style.paddingLeft = '4px';

                        const participationCheck = document.createElement('input');
                        participationCheck.type = 'checkbox';
                        participationCheck.checked = question.awardParticipationPoints || false;
                        participationCheck.style.cursor = 'pointer';
                        participationCheck.style.width = '16px';
                        participationCheck.style.height = '16px';
                        participationCheck.style.margin = '0';
                        participationCheck.onchange = () => {
                            question.awardParticipationPoints = participationCheck.checked;
                            console.log(`‚úèÔ∏è Updated question ${index + 1} awardParticipationPoints:`, participationCheck.checked, 'Full question:', question);
                            // Save to sessionStorage so display view gets the updated value
                            sessionStorage.setItem('questionQueue_' + sessionCode, JSON.stringify(questionQueue));
                            saveQueueToBackend();
                        };

                        participationCheckContainer.appendChild(participationCheck);

                        const participationText = document.createElement('span');
                        participationText.textContent = 'Participation points';

                        // Add to grid in row order
                        settings.appendChild(timeLabel);
                        settings.appendChild(timeInput);
                        settings.appendChild(timeUnit);
                        settings.appendChild(pointsLabel);
                        settings.appendChild(pointsInput);
                        settings.appendChild(pointsUnit);
                        settings.appendChild(participationLabel);
                        settings.appendChild(participationCheckContainer);
                        settings.appendChild(participationText);

                        // Actions section (right side)
                        const actions = document.createElement('div');
                        actions.style.display = 'flex';
                        actions.style.gap = '6px';
                        actions.style.flexShrink = '0';

                        // Reorder buttons - always show both, disable when needed
                        const upBtn = document.createElement('button');
                        upBtn.className = 'btn btn-secondary';
                        upBtn.style.padding = '6px 10px';
                        upBtn.style.fontSize = '12px';
                        upBtn.style.minWidth = '32px';
                        upBtn.innerHTML = '‚Üë';
                        upBtn.title = 'Move up';

                        // Disable up button for first question
                        const canMoveUp = index > currentQuestionIndex + 1;
                        if (!canMoveUp) {
                            upBtn.disabled = true;
                            upBtn.style.opacity = '0.3';
                            upBtn.style.cursor = 'not-allowed';
                        } else {
                            upBtn.onclick = () => moveQuestion(index, -1);
                        }
                        actions.appendChild(upBtn);

                        const downBtn = document.createElement('button');
                        downBtn.className = 'btn btn-secondary';
                        downBtn.style.padding = '6px 10px';
                        downBtn.style.fontSize = '12px';
                        downBtn.style.minWidth = '32px';
                        downBtn.innerHTML = '‚Üì';
                        downBtn.title = 'Move down';

                        // Disable down button for last question
                        const canMoveDown = index < questionQueue.length - 1;
                        if (!canMoveDown) {
                            downBtn.disabled = true;
                            downBtn.style.opacity = '0.3';
                            downBtn.style.cursor = 'not-allowed';
                        } else {
                            downBtn.onclick = () => moveQuestion(index, 1);
                        }
                        actions.appendChild(downBtn);

                        const editBtn = document.createElement('button');
                        editBtn.className = 'btn btn-secondary';
                        editBtn.style.padding = '6px 12px';
                        editBtn.style.fontSize = '12px';
                        editBtn.textContent = 'Edit';
                        editBtn.onclick = () => editQueueQuestion(index);
                        actions.appendChild(editBtn);

                        const removeBtn = document.createElement('button');
                        removeBtn.className = 'btn btn-secondary';
                        removeBtn.style.padding = '6px 12px';
                        removeBtn.style.fontSize = '12px';
                        removeBtn.textContent = 'Remove';
                        removeBtn.onclick = () => removeFromQueue(index);
                        actions.appendChild(removeBtn);

                        settingsAndActions.appendChild(settings);
                        settingsAndActions.appendChild(actions);

                        item.appendChild(questionHeader);
                        item.appendChild(settingsAndActions);
                    } else {
                        // Already sent questions - simple display
                        item.appendChild(questionHeader);
                        item.style.opacity = '0.6';
                        item.style.backgroundColor = 'var(--bg-secondary)';
                    }

                    queueList.appendChild(item);
                });
                
                document.getElementById('sendBtn').disabled = false;
            }
        }

        function removeFromQueue(index) {
            questionQueue.splice(index, 1);
            updateQueueDisplay();
        }

        function moveQuestion(index, direction) {
            const newIndex = index + direction;

            // Prevent moving past boundaries
            if (newIndex <= currentQuestionIndex || newIndex >= questionQueue.length) {
                return;
            }

            // Swap questions
            const temp = questionQueue[index];
            questionQueue[index] = questionQueue[newIndex];
            questionQueue[newIndex] = temp;

            updateQueueDisplay();
            toast.success('Question moved');
        }

        let editingQuestionIndex = null;

        function editQueueQuestion(index) {
            editingQuestionIndex = index;
            const question = questionQueue[index];

            // Open the question modal
            document.getElementById('questionModal').style.display = 'block';

            // Detect if this is a poll question (no correct answer)
            const isPoll = !question.correctAnswer && question.correctAnswer !== 0 && question.correctAnswer !== false;
            const questionType = isPoll ? 'poll' : (question.type || question.questionType || 'mcq');

            logger.debug('Editing question:', {
                type: questionType,
                isPoll,
                correctAnswer: question.correctAnswer,
                options: question.options || question.optionTexts
            });

            document.getElementById('modalQuestionType').value = questionType;
            document.getElementById('modalQuestionText').value = question.text || question.questionText || '';

            // Pre-fill time, points, and participation settings
            document.getElementById('modalTimeLimit').value = question.timeLimit || 60;
            document.getElementById('modalPoints').value = question.points || 10;
            document.getElementById('modalAwardParticipation').checked = question.awardParticipationPoints || false;

            // Update options display after type is set
            setTimeout(() => updateModalOptions(), 10);

            // Pre-fill data based on question type
            setTimeout(() => {
                switch(questionType) {
                    case 'poll':
                        // Poll questions have options but no correct answer
                        if (question.options || question.optionTexts) {
                            const options = question.optionTexts || question.options;
                            ['A', 'B', 'C', 'D'].forEach((letter, idx) => {
                                const input = document.getElementById(`modalOption${letter}`);
                                if (input && options[idx]) {
                                    input.value = options[idx];
                                }
                            });
                        }
                        break;

                    case 'mcq':
                        if (question.optionTexts || question.options) {
                            const options = question.optionTexts || question.options;
                            ['A', 'B', 'C', 'D'].forEach((letter, idx) => {
                                const input = document.getElementById(`modalOption${letter}`);
                                if (input && options[idx]) {
                                    input.value = options[idx];
                                }
                                if (question.correctAnswer === letter || question.correctAnswer === idx) {
                                    const radio = document.querySelector(`input[name="modalCorrect"][value="${letter}"]`);
                                    if (radio) radio.checked = true;
                                }
                            });
                        }
                        break;

                    case 'tf':
                        const tfValue = question.correctAnswer === 'true' || question.correctAnswer === true ? 'true' : 'false';
                        const tfRadio = document.querySelector(`input[name="modalTF"][value="${tfValue}"]`);
                        if (tfRadio) tfRadio.checked = true;
                        break;

                    case 'matching':
                        if (question.pairs) {
                            question.pairs.forEach((pair, idx) => {
                                const leftInput = document.getElementById(`modalMatch${idx + 1}Left`);
                                const rightInput = document.getElementById(`modalMatch${idx + 1}Right`);
                                if (leftInput) leftInput.value = pair.left || '';
                                if (rightInput) rightInput.value = pair.right || '';
                            });
                        }
                        break;

                    case 'ordering':
                        if (question.correctOrder) {
                            question.correctOrder.forEach((item, idx) => {
                                const input = document.getElementById(`modalOrder${idx + 1}`);
                                if (input) input.value = item || '';
                            });
                        }
                        break;

                    case 'fillblank':
                        const answerInput = document.getElementById('modalBlankAnswer');
                        if (answerInput) answerInput.value = question.correctAnswer || '';
                        break;
                }
            }, 100);

            // Change modal title
            const modalTitle = document.querySelector('#questionModal h2');
            if (modalTitle) modalTitle.textContent = 'Edit Question';
        }

        async function sendNextQuestion() {
            console.log('üöÄ SEND NEXT QUESTION CALLED:', {
                currentIndex: currentQuestionIndex,
                queueLength: questionQueue.length,
                willPassCheck: (currentQuestionIndex + 1 < questionQueue.length),
                nextQuestion: questionQueue[currentQuestionIndex + 1]
            });

            if (currentQuestionIndex + 1 >= questionQueue.length) {
                toast.error('No more questions in queue');
                return;
            }

            currentQuestionIndex++;

            // Save updated index to sessionStorage
            sessionStorage.setItem('questionIndex_' + sessionCode, currentQuestionIndex.toString());

            const question = questionQueue[currentQuestionIndex];

            console.log('üîç QUESTION FROM QUEUE (before normalization):', {
                index: currentQuestionIndex,
                timeLimit: question.timeLimit,
                points: question.points,
                awardParticipationPoints: question.awardParticipationPoints,
                fullQuestion: question
            });

            // Normalize question type for student interface compatibility
            const normalizedQuestion = {...question};

            console.log('üîç NORMALIZED QUESTION (after spread):', {
                timeLimit: normalizedQuestion.timeLimit,
                points: normalizedQuestion.points,
                awardParticipationPoints: normalizedQuestion.awardParticipationPoints,
                fullQuestion: normalizedQuestion
            });

            // Remove the original 'type' field to avoid confusion
            delete normalizedQuestion.type;

            // Map our types to what the student interface expects
            const typeMap = {
                'mcq': 'multiple_choice',
                'tf': 'boolean',  // Try 'boolean' instead of 'true_false'
                'matching': 'matching',
                'ordering': 'ordering',
                'fillblank': 'fill_blank'
            };

            // Set both questionType and type to the mapped value
            const mappedType = typeMap[question.type] || question.type;
            normalizedQuestion.questionType = mappedType;
            normalizedQuestion.type = mappedType;

            // Ensure questionText is set
            normalizedQuestion.questionText = question.text || question.questionText;

            // Handle type-specific data
            if (question.type === 'tf') {
                // For true/false, ensure options are properly formatted
                normalizedQuestion.options = ['True', 'False'];
            } else if (question.type === 'mcq') {
                // Ensure MCQ has options and optionTexts
                if (question.optionTexts) {
                    normalizedQuestion.options = question.options;
                    normalizedQuestion.optionTexts = question.optionTexts;
                }
            } else if (question.type === 'matching') {
                // Ensure matching has pairs
                normalizedQuestion.pairs = question.pairs || [];
                // Shuffle the right column items ONCE here, so both instructor and student see same order
                const rightItems = normalizedQuestion.pairs.map(p => p.right);
                const shuffledRight = rightItems.sort(() => Math.random() - 0.5);
                normalizedQuestion.shuffledMatchingRight = shuffledRight;
                console.log('üé≤ MATCHING SHUFFLE DEBUG:', {
                    originalPairs: normalizedQuestion.pairs,
                    originalRight: rightItems,
                    shuffledRight: shuffledRight
                });
            } else if (question.type === 'ordering') {
                // Ensure ordering has correctOrder
                normalizedQuestion.correctOrder = question.correctOrder || [];
                // Shuffle the items ONCE here, so both instructor and student see same order
                const shuffledItems = [...normalizedQuestion.correctOrder].sort(() => Math.random() - 0.5);
                normalizedQuestion.shuffledOrderingItems = shuffledItems;
                console.log('üé≤ ORDERING SHUFFLE DEBUG:', {
                    originalOrder: normalizedQuestion.correctOrder,
                    shuffledItems: shuffledItems
                });
            } else if (question.type === 'fillblank') {
                // Ensure fill-in-blank has correctAnswer
                normalizedQuestion.correctAnswer = question.correctAnswer || '';
            }
            
            // Debug logging
            console.log('üì§ SENDING QUESTION TO BACKEND:', {
                sessionId: sessionId,
                questionType: normalizedQuestion.questionType,
                type: normalizedQuestion.type,
                timeLimit: normalizedQuestion.timeLimit,
                points: normalizedQuestion.points,
                awardParticipationPoints: normalizedQuestion.awardParticipationPoints,
                shuffledMatchingRight: normalizedQuestion.shuffledMatchingRight,
                shuffledOrderingItems: normalizedQuestion.shuffledOrderingItems,
                fullQuestion: normalizedQuestion
            });
            logger.debug('Sending question:', {
                sessionId: sessionId,
                endpoint: `https://api-modular.intellaclick.com/api/sessions/${sessionId}/questions`,
                questionData: normalizedQuestion,
                hasQuestionText: !!normalizedQuestion.questionText,
                questionType: normalizedQuestion.questionType
            });

            console.log('üåê MAKING FETCH REQUEST:', {
                url: `https://api-modular.intellaclick.com/api/sessions/${sessionId}/questions`,
                method: 'POST',
                timeLimit: normalizedQuestion.timeLimit,
                points: normalizedQuestion.points
            });

            try {
                const response = await fetch(`https://api-modular.intellaclick.com/api/sessions/${sessionId}/questions`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    },
                    body: JSON.stringify(normalizedQuestion)
                });

                console.log('üì° FETCH RESPONSE:', {
                    status: response.status,
                    ok: response.ok
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.log('‚ùå FETCH ERROR:', errorData);
                    logger.error('API Error:', {
                        status: response.status,
                        error: errorData
                    });
                    throw new Error(errorData.error || 'Failed to send question');
                }

                const result = await response.json();
                console.log('‚úÖ FETCH SUCCESS:', result);
                logger.debug('Question sent successfully:', result);

                toast.success('Question sent successfully!');
                document.getElementById('stopBtn').disabled = false;
                document.getElementById('resultsBtn').disabled = false;

                // Display current question immediately
                displayCurrentQuestion(question);

                // Update queue display
                updateQueueDisplay();

                // Wait a bit for server to save, then reload session
                setTimeout(async () => {
                    await loadSession();
                }, 500);
            } catch (error) {
                logger.error('Error sending question:', error);
                
                // Check if it's a CORS error
                if (error.name === 'TypeError' && error.message === 'Failed to fetch') {
                    toast.error('Network error: Unable to reach the API server. This may be a CORS issue.');
                    logger.error('CORS Error Details:', {
                        error: error,
                        message: 'The API server may need to add instructor.intellaclick.com to its allowed origins',
                        currentOrigin: window.location.origin,
                        apiUrl: 'https://api-modular.intellaclick.com'
                    });
                    
                    // Show more detailed error in alert for debugging
                    if (window.confirm('Network error detected. This is likely a CORS configuration issue.\n\nThe backend needs to add instructor.intellaclick.com to its allowed origins.\n\nClick OK to open the CORS test page for more details.')) {
                        window.open('/cors-test.html', '_blank');
                    }
                } else {
                    toast.error(error.message || 'Failed to send question');
                }
                
                currentQuestionIndex--; // Revert on error
            }
        }

        function displayCurrentQuestion(question) {
            document.getElementById('currentQuestionSection').style.display = 'block';

            // Normalize question format (handle both local queue format and server format)
            const questionType = question.type || question.questionType;
            const questionText = question.text || question.questionText || '';

            // DEBUG: Log question data
            logger.debug('üì∫ DISPLAYING QUESTION IN SESSION CONTROL:', {
                questionType,
                questionText,
                hasPairs: !!question.pairs,
                pairs: question.pairs,
                hasCorrectOrder: !!question.correctOrder,
                correctOrder: question.correctOrder,
                fullQuestion: question
            });

            // Display question text with blanks rendered as visual blanks
            let questionTextHtml = questionText;
            if (questionType === 'fillblank' || questionType === 'fill_blank') {
                // Replace [blank] with a styled visual blank
                questionTextHtml = questionTextHtml.replace(/\[blank\]/gi, '<span style="display: inline-block; min-width: 100px; border-bottom: 2px solid #4F46E5; margin: 0 6px; height: 1.2em; vertical-align: bottom;"></span>');
            }
            document.getElementById('questionText').innerHTML = questionTextHtml;

            // Display options based on question type
            const optionsDiv = document.getElementById('questionOptions');
            optionsDiv.innerHTML = '';

            if ((questionType === 'mcq' || questionType === 'multiple_choice') && (question.optionTexts || question.options)) {
                const optionTexts = question.optionTexts || question.options;
                const optionLetters = question.options && question.optionTexts ? question.options : ['A', 'B', 'C', 'D'];
                optionLetters.forEach((option, index) => {
                    if (optionTexts[index]) {
                        const optionEl = document.createElement('div');
                        optionEl.style.marginTop = '8px';
                        optionEl.textContent = `${option}: ${optionTexts[index]}`;
                        optionsDiv.appendChild(optionEl);
                    }
                });
            } else if (questionType === 'tf' || questionType === 'boolean') {
                optionsDiv.innerHTML = '<div style="margin-top: 8px;">A: True</div><div style="margin-top: 8px;">B: False</div>';
            } else if (questionType === 'matching' && question.pairs) {
                optionsDiv.innerHTML = '<strong>Match the following:</strong>';
                // Display left column (stays in order)
                question.pairs.forEach((pair, index) => {
                    const pairEl = document.createElement('div');
                    pairEl.style.marginTop = '8px';
                    pairEl.textContent = `${index + 1}. ${pair.left} ‚Üí ?`;
                    optionsDiv.appendChild(pairEl);
                });
                // Display shuffled right column that students will see
                if (question.shuffledMatchingRight) {
                    const rightDiv = document.createElement('div');
                    rightDiv.style.marginTop = '12px';
                    rightDiv.innerHTML = '<strong>Options to match:</strong>';
                    question.shuffledMatchingRight.forEach((item, index) => {
                        const optEl = document.createElement('div');
                        optEl.style.marginTop = '4px';
                        optEl.textContent = `${String.fromCharCode(65 + index)}. ${item}`;
                        rightDiv.appendChild(optEl);
                    });
                    optionsDiv.appendChild(rightDiv);
                }
            } else if ((questionType === 'ordering' || questionType === 'ordering') && question.correctOrder) {
                optionsDiv.innerHTML = '<strong>Put in correct order:</strong>';
                // Use shuffled order if available (same order students see)
                const itemsToDisplay = question.shuffledOrderingItems || question.correctOrder;
                itemsToDisplay.forEach((item, index) => {
                    const itemEl = document.createElement('div');
                    itemEl.style.marginTop = '8px';
                    itemEl.textContent = `${String.fromCharCode(65 + index)}. ${item}`;
                    optionsDiv.appendChild(itemEl);
                });
            }
        }

        // Modal Functions
        function showQuestionModal() {
            document.getElementById('questionModal').style.display = 'block';
            updateModalOptions(); // Initialize with default options
        }

        function closeQuestionModal() {
            document.getElementById('questionModal').style.display = 'none';
            // Clear form
            document.getElementById('modalQuestionText').value = '';
            document.getElementById('modalQuestionType').value = 'mcq';
            // Reset editing mode
            editingQuestionIndex = null;
            // Reset modal title
            const modalTitle = document.querySelector('#questionModal h2');
            if (modalTitle) modalTitle.textContent = 'Create Question';
        }

        function showImportModal() {
            document.getElementById('importModal').style.display = 'block';
            loadQuizzes();
        }

        function closeImportModal() {
            document.getElementById('importModal').style.display = 'none';
            selectedQuizId = null;
        }

        function updateModalOptions() {
            const type = document.getElementById('modalQuestionType').value;
            const optionsDiv = document.getElementById('modalQuestionOptions');

            switch(type) {
                case 'poll':
                    optionsDiv.innerHTML = `
                        <label>Poll Options (no correct answer - all answers award participation points)</label>
                        <div style="margin-top: 8px;">
                            <input type="text" id="modalOptionA" placeholder="Option A" style="width: 100%; margin-bottom: 8px;">
                        </div>
                        <div style="margin-top: 8px;">
                            <input type="text" id="modalOptionB" placeholder="Option B" style="width: 100%; margin-bottom: 8px;">
                        </div>
                        <div style="margin-top: 8px;">
                            <input type="text" id="modalOptionC" placeholder="Option C" style="width: 100%; margin-bottom: 8px;">
                        </div>
                        <div style="margin-top: 8px;">
                            <input type="text" id="modalOptionD" placeholder="Option D" style="width: 100%;">
                        </div>
                        <small style="display: block; margin-top: 8px; color: var(--text-secondary);">
                            üí° Poll questions have no correct answer. All students who answer receive participation points.
                        </small>
                    `;
                    break;

                case 'mcq':
                    optionsDiv.innerHTML = `
                        <label>Answer Options (select correct answer)</label>
                        <div style="margin-top: 8px;">
                            <input type="radio" name="modalCorrect" value="A" checked>
                            <input type="text" id="modalOptionA" placeholder="Option A" style="width: calc(100% - 30px); margin-left: 8px;">
                        </div>
                        <div style="margin-top: 8px;">
                            <input type="radio" name="modalCorrect" value="B">
                            <input type="text" id="modalOptionB" placeholder="Option B" style="width: calc(100% - 30px); margin-left: 8px;">
                        </div>
                        <div style="margin-top: 8px;">
                            <input type="radio" name="modalCorrect" value="C">
                            <input type="text" id="modalOptionC" placeholder="Option C" style="width: calc(100% - 30px); margin-left: 8px;">
                        </div>
                        <div style="margin-top: 8px;">
                            <input type="radio" name="modalCorrect" value="D">
                            <input type="text" id="modalOptionD" placeholder="Option D" style="width: calc(100% - 30px); margin-left: 8px;">
                        </div>
                    `;
                    break;
                    
                case 'tf':
                    optionsDiv.innerHTML = `
                        <label>Correct Answer</label>
                        <div style="margin-top: 8px;">
                            <input type="radio" name="modalTF" value="true" checked> True
                            <input type="radio" name="modalTF" value="false" style="margin-left: 20px;"> False
                        </div>
                    `;
                    break;
                    
                case 'matching':
                    optionsDiv.innerHTML = `
                        <label>Matching Pairs</label>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 8px;">
                            <input type="text" placeholder="Item 1" id="modalMatch1Left">
                            <input type="text" placeholder="Match 1" id="modalMatch1Right">
                            <input type="text" placeholder="Item 2" id="modalMatch2Left">
                            <input type="text" placeholder="Match 2" id="modalMatch2Right">
                            <input type="text" placeholder="Item 3" id="modalMatch3Left">
                            <input type="text" placeholder="Match 3" id="modalMatch3Right">
                        </div>
                    `;
                    break;
                    
                case 'ordering':
                    optionsDiv.innerHTML = `
                        <label>Items in Correct Order</label>
                        <div style="margin-top: 8px;">
                            <input type="text" placeholder="1st item" id="modalOrder1" style="margin-bottom: 8px;">
                            <input type="text" placeholder="2nd item" id="modalOrder2" style="margin-bottom: 8px;">
                            <input type="text" placeholder="3rd item" id="modalOrder3" style="margin-bottom: 8px;">
                            <input type="text" placeholder="4th item" id="modalOrder4">
                        </div>
                    `;
                    break;
                    
                case 'fillblank':
                    optionsDiv.innerHTML = `
                        <label>Correct Answer</label>
                        <input type="text" id="modalBlankAnswer" placeholder="Enter the correct answer" style="margin-top: 8px;">
                        <small style="display: block; margin-top: 8px; color: var(--text-secondary);">Use [blank] in your question where the answer should go</small>
                    `;
                    break;
            }
        }

        async function stopQuestion() {
            try {
                // Get current question ID from session data
                const questionId = sessionData.currentQuestion?.questionId || 'current';
                
                const response = await fetch(`https://api-modular.intellaclick.com/api/sessions/${sessionId}/questions/${questionId}/end`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    }
                });

                if (!response.ok) throw new Error('Failed to stop question');

                toast.success('Question stopped');
                document.getElementById('currentQuestionSection').style.display = 'none';
                await loadSession();
            } catch (error) {
                logger.error('Error stopping question:', error);
                toast.error('Failed to stop question');
            }
        }

        async function showResults() {
            try {
                // Fetch responses from backend
                const response = await fetch(`https://api-modular.intellaclick.com/api/sessions/code/${sessionCode}/responses`);
                const data = await response.json();

                if (!data.success) {
                    toast.error('Failed to load results');
                    return;
                }

                // Display the responses section
                document.getElementById('responsesSection').style.display = 'block';

                // Render results
                renderResults(data.responses, data.responsesByQuestion);

                // Scroll to results
                document.getElementById('responsesSection').scrollIntoView({ behavior: 'smooth' });

            } catch (error) {
                console.error('Error fetching results:', error);
                toast.error('Failed to load results');
            }
        }

        function renderResults(responses, responsesByQuestion) {
            const chartDiv = document.getElementById('responseChart');

            if (!responses || responses.length === 0) {
                chartDiv.innerHTML = '<p style="color: var(--text-secondary); text-align: center; padding: 40px;">No responses yet</p>';
                return;
            }

            let html = `<h3>Session Results Summary</h3>`;
            html += `<p style="margin-bottom: 20px; color: var(--text-secondary);">Total Responses: ${responses.length}</p>`;

            // Group by question
            for (const [questionId, questionResponses] of Object.entries(responsesByQuestion)) {
                // Find the question text from session data
                const question = sessionData.questions?.find(q => q._id === questionId) || sessionData.currentQuestion;
                const questionText = question?.text || 'Unknown Question';
                const questionType = question?.type || 'unknown';
                const options = question?.options || [];
                const correctAnswer = question?.correctAnswer;

                html += `
                    <div style="background: white; border-radius: 8px; padding: 20px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                        <h4 style="margin-bottom: 16px;">${questionText}</h4>
                        <p style="color: var(--text-secondary); font-size: 13px; margin-bottom: 12px;">
                            ${questionResponses.length} response${questionResponses.length !== 1 ? 's' : ''}
                        </p>
                `;

                // Count answers for visualization
                const answerCounts = {};
                questionResponses.forEach(r => {
                    const answer = r.answer;
                    answerCounts[answer] = (answerCounts[answer] || 0) + 1;
                });

                // Show answer distribution for multiple choice
                if (questionType === 'multiple_choice' || questionType === 'mcq') {
                    html += '<div style="margin-bottom: 20px;">';
                    options.forEach((option, index) => {
                        const count = answerCounts[index] || 0;
                        const percentage = Math.round((count / questionResponses.length) * 100) || 0;
                        const isCorrect = correctAnswer === index;

                        html += `
                            <div style="margin-bottom: 12px;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                                    <span style="font-weight: 500;">
                                        ${option} ${isCorrect ? '<span style="color: var(--secondary-color);">‚úì Correct</span>' : ''}
                                    </span>
                                    <span style="color: var(--text-secondary);">${count} (${percentage}%)</span>
                                </div>
                                <div style="background: #E5E7EB; height: 8px; border-radius: 4px; overflow: hidden;">
                                    <div style="background: ${isCorrect ? 'var(--secondary-color)' : 'var(--primary-color)'}; height: 100%; width: ${percentage}%; transition: width 0.3s;"></div>
                                </div>
                            </div>
                        `;
                    });
                    html += '</div>';
                }

                // Show student responses
                html += '<details style="margin-top: 16px;">';
                html += '<summary style="cursor: pointer; color: var(--primary-color); font-weight: 500;">View individual responses</summary>';
                html += '<div style="margin-top: 12px; max-height: 300px; overflow-y: auto;">';
                html += '<table style="width: 100%; border-collapse: collapse;">';
                html += '<tr style="background: #F9FAFB;"><th style="text-align: left; padding: 8px;">Student</th><th style="text-align: left; padding: 8px;">Answer</th><th style="text-align: left; padding: 8px;">Time</th></tr>';

                questionResponses.forEach(r => {
                    const answerText = questionType === 'multiple_choice' || questionType === 'mcq'
                        ? options[r.answer] || r.answer
                        : r.answer;
                    const time = r.submittedAt ? new Date(r.submittedAt).toLocaleTimeString() : 'N/A';

                    html += `
                        <tr style="border-bottom: 1px solid #E5E7EB;">
                            <td style="padding: 8px;">${r.participantName}</td>
                            <td style="padding: 8px;">${answerText}</td>
                            <td style="padding: 8px; color: var(--text-secondary);">${time}</td>
                        </tr>
                    `;
                });

                html += '</table></div></details>';
                html += '</div>';
            }

            chartDiv.innerHTML = html;
        }

        async function endSession() {
            if (!confirm('Are you sure you want to end this session?')) return;

            try {
                // Check if gamification is enabled for this session
                const hasGamification = sessionData?.gamification?.enabled && sessionData?.classId;

                let response;
                if (hasGamification) {
                    logger.debug('Ending session with gamification processing...');
                    // Use gamification endpoint which processes points, levels, achievements
                    response = await fetch(`https://api-modular.intellaclick.com/api/sessions-gamified/${sessionId}/end-with-gamification`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${localStorage.getItem('token')}`
                        }
                    });
                } else {
                    logger.debug('Ending session (no gamification)...');
                    // Use regular endpoint
                    response = await fetch(`https://api-modular.intellaclick.com/api/sessions/${sessionId}/status`, {
                        method: 'PATCH',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${localStorage.getItem('token')}`
                        },
                        body: JSON.stringify({ status: 'ended' })
                    });
                }

                if (!response.ok) throw new Error('Failed to end session');

                const result = await response.json();
                logger.debug('Session ended:', result);

                if (hasGamification && result.gamificationResults) {
                    toast.success(`Session ended - ${result.gamificationResults.length} students earned points!`);
                } else {
                    toast.success('Session ended');
                }

                stopPolling();
                setTimeout(() => window.location.href = 'classes.html', 2000);
            } catch (error) {
                logger.error('Error ending session:', error);
                toast.error('Failed to end session');
            }
        }

        function startPolling() {
            // Poll for updates every 3 seconds
            pollInterval = setInterval(loadSession, 3000);
        }

        function stopPolling() {
            if (pollInterval) {
                clearInterval(pollInterval);
            }
        }

        function openDisplayView() {
            const displayUrl = `display.html?id=${sessionId}&code=${sessionCode}`;
            window.open(displayUrl, 'IntellaClickDisplay', 'width=1920,height=1080,menubar=no,toolbar=no,location=no,status=no');
        }


        function copyJoinUrl(url) {
            navigator.clipboard.writeText(url).then(() => {
                toast.success('Link copied to clipboard!');
            }).catch(err => {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = url;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    toast.success('Link copied to clipboard!');
                } catch (err) {
                    toast.error('Failed to copy link');
                }
                document.body.removeChild(textArea);
            });
        }

        function copySessionCode() {
            const code = document.getElementById('sessionCode').textContent;
            navigator.clipboard.writeText(code).then(() => {
                toast.success('Session code copied!');
            }).catch(err => {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = code;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    toast.success('Session code copied!');
                } catch (err) {
                    toast.error('Failed to copy code');
                }
                document.body.removeChild(textArea);
            });
        }

        // Add Question to Queue
        function addQuestionToQueue() {
            const questionText = document.getElementById('modalQuestionText').value.trim();
            const questionType = document.getElementById('modalQuestionType').value;

            if (!questionText) {
                toast.error('Please enter a question');
                return;
            }

            // Read values from modal inputs
            const timeLimit = parseInt(document.getElementById('modalTimeLimit').value) || 60;
            const points = parseInt(document.getElementById('modalPoints').value) || 10;
            const awardParticipation = document.getElementById('modalAwardParticipation').checked;

            let question = {
                text: questionText,
                type: questionType,
                timeLimit: timeLimit,  // ‚úÖ Read from input
                points: points,        // ‚úÖ Read from input
                awardParticipationPoints: awardParticipation  // ‚úÖ Read from checkbox
            };
            
            // Build question based on type
            switch(questionType) {
                case 'poll':
                    // Poll questions have options but no correct answer
                    const pollOptions = [];
                    const pollOptionTexts = [];

                    ['A', 'B', 'C', 'D'].forEach(letter => {
                        const optionInput = document.getElementById(`modalOption${letter}`);
                        if (optionInput && optionInput.value.trim()) {
                            pollOptions.push(letter);
                            pollOptionTexts.push(optionInput.value.trim());
                        }
                    });

                    if (pollOptions.length < 2) {
                        toast.error('Please provide at least 2 options');
                        return;
                    }

                    question.type = 'mcq'; // Use mcq type for backend compatibility
                    question.options = pollOptions;
                    question.optionTexts = pollOptionTexts;
                    // No correctAnswer for poll questions
                    question.awardParticipationPoints = true; // Always award participation for polls
                    break;

                case 'mcq':
                    const options = [];
                    const optionTexts = [];
                    let correctAnswer = null;

                    ['A', 'B', 'C', 'D'].forEach(letter => {
                        const optionInput = document.getElementById(`modalOption${letter}`);
                        if (optionInput && optionInput.value.trim()) {
                            options.push(letter);
                            optionTexts.push(optionInput.value.trim());

                            const radio = document.querySelector(`input[name="modalCorrect"][value="${letter}"]`);
                            if (radio && radio.checked) {
                                correctAnswer = letter;
                            }
                        }
                    });

                    if (options.length < 2) {
                        toast.error('Please provide at least 2 options');
                        return;
                    }

                    question.options = options;
                    question.optionTexts = optionTexts;
                    question.correctAnswer = correctAnswer;
                    break;
                    
                case 'tf':
                    question.options = ['True', 'False'];
                    question.correctAnswer = document.querySelector('input[name="modalTF"]:checked').value;
                    break;
                    
                case 'matching':
                    const pairs = [];
                    for (let i = 1; i <= 3; i++) {
                        const left = document.getElementById(`modalMatch${i}Left`).value.trim();
                        const right = document.getElementById(`modalMatch${i}Right`).value.trim();
                        if (left && right) {
                            pairs.push({ left, right });
                        }
                    }
                    
                    if (pairs.length < 2) {
                        toast.error('Please provide at least 2 matching pairs');
                        return;
                    }
                    
                    question.pairs = pairs;
                    break;
                    
                case 'ordering':
                    const items = [];
                    for (let i = 1; i <= 4; i++) {
                        const item = document.getElementById(`modalOrder${i}`).value.trim();
                        if (item) {
                            items.push(item);
                        }
                    }
                    
                    if (items.length < 2) {
                        toast.error('Please provide at least 2 items');
                        return;
                    }
                    
                    question.correctOrder = items;
                    break;
                    
                case 'fillblank':
                    const answer = document.getElementById('modalBlankAnswer').value.trim();
                    if (!answer) {
                        toast.error('Please provide the correct answer');
                        return;
                    }
                    
                    if (!questionText.includes('[blank]')) {
                        toast.error('Please include [blank] in your question');
                        return;
                    }
                    
                    question.correctAnswer = answer;
                    break;
            }
            
            // Add to queue or update existing
            if (editingQuestionIndex !== null) {
                // Update existing question
                questionQueue[editingQuestionIndex] = question;
                editingQuestionIndex = null;
                toast.success('Question updated');
            } else {
                // Add new question
                questionQueue.push(question);
                toast.success('Question added to queue');
            }

            updateQueueDisplay();
            closeQuestionModal();
        }

        // Load and Import Quizzes
        async function loadQuizzes() {
            try {
                const response = await fetch(`https://api-modular.intellaclick.com/api/quizzes`, {
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    }
                });

                if (!response.ok) throw new Error('Failed to load quizzes');

                const data = await response.json();
                const quizzes = data.quizzes || [];

                const quizList = document.getElementById('quizList');
                if (quizzes.length === 0) {
                    quizList.innerHTML = '<p style="color: var(--text-secondary); text-align: center; padding: 20px;">No quizzes found. <a href="saved-questions.html" style="color: var(--primary-color);">Create your first quiz</a></p>';
                    document.getElementById('importBtn').disabled = true;
                } else {
                    quizList.innerHTML = '';
                    quizzes.forEach(quiz => {
                        const item = document.createElement('div');
                        item.className = 'quiz-item';
                        item.innerHTML = `
                            <strong>${quiz.title}</strong><br>
                            <small style="color: var(--text-secondary);">${quiz.questionCount || 0} questions ‚Ä¢ ${quiz.totalPoints || 0} points</small>
                        `;
                        item.onclick = () => selectQuiz(quiz._id, item);
                        quizList.appendChild(item);
                    });
                }
            } catch (error) {
                logger.error('Error loading quizzes:', error);
                const quizList = document.getElementById('quizList');
                quizList.innerHTML = '<p style="color: var(--danger-color); text-align: center; padding: 20px;">Failed to load quizzes. Please try again.</p>';
            }
        }

        function selectQuiz(quizId, element) {
            selectedQuizId = quizId;
            
            // Update UI
            document.querySelectorAll('.quiz-item').forEach(item => {
                item.classList.remove('selected');
            });
            element.classList.add('selected');
            
            document.getElementById('importBtn').disabled = false;
        }

        async function importSelectedQuiz() {
            if (!selectedQuizId) {
                toast.error('Please select a quiz');
                return;
            }

            try {
                const response = await fetch(`https://api-modular.intellaclick.com/api/quizzes/${selectedQuizId}`, {
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    }
                });

                if (!response.ok) throw new Error('Failed to load quiz');

                const data = await response.json();
                const quiz = data.quiz || data;

                if (quiz.questions && quiz.questions.length > 0) {
                    logger.debug('üìã Applying question defaults to imported quiz:', questionDefaults);

                    // Add all quiz questions to the queue
                    quiz.questions.forEach(q => {
                        // Get question data from snapshot if available
                        const snapshot = q.questionSnapshot || q;

                        // Check both questionType (new schema) and type (old data) for backwards compatibility
                        const questionType = snapshot.questionType || snapshot.type || 'mcq';

                        const question = {
                            text: snapshot.questionText || q.text || '',
                            type: questionType,
                            options: snapshot.options || [],
                            correctAnswer: snapshot.correctAnswer || 0,
                            timeLimit: snapshot.timeLimit || q.timeLimit || questionDefaults.defaultTimeLimit, // ‚úÖ Use default
                            points: snapshot.points || q.points || questionDefaults.defaultPoints, // ‚úÖ Use default
                            awardParticipationPoints: questionDefaults.defaultAwardParticipation // ‚úÖ Apply default
                        };

                        // Add matching question data
                        if (question.type === 'matching' && snapshot.pairs) {
                            question.pairs = snapshot.pairs;
                            logger.debug('üì¶ Imported matching question with pairs:', snapshot.pairs);
                        }

                        // Add ordering question data
                        if (question.type === 'ordering' && snapshot.correctOrder) {
                            question.correctOrder = snapshot.correctOrder;
                            logger.debug('üì¶ Imported ordering question with correctOrder:', snapshot.correctOrder);
                        }

                        questionQueue.push(question);
                    });

                    updateQueueDisplay();
                    closeImportModal();
                    toast.success(`Imported ${quiz.questions.length} questions from ${quiz.title}`);
                } else {
                    toast.error('Quiz has no questions');
                }
            } catch (error) {
                logger.error('Error importing quiz:', error);
                toast.error('Failed to import quiz');
            }
        }

        // Close modals when clicking outside
        window.onclick = function(event) {
            if (event.target.className === 'modal') {
                event.target.style.display = 'none';
            }
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', stopPolling);

        // Expose functions to window for onclick handlers
        window.copySessionCode = copySessionCode;
        window.openDisplayView = openDisplayView;
        window.showQuestionModal = showQuestionModal;
        window.showImportModal = showImportModal;
        window.sendNextQuestion = sendNextQuestion;
        window.stopQuestion = stopQuestion;
        window.showResults = showResults;
        window.loadSession = loadSession;
        window.endSession = endSession;
        window.closeQuestionModal = closeQuestionModal;
        window.addQuestionToQueue = addQuestionToQueue;
        window.closeImportModal = closeImportModal;
        window.importSelectedQuiz = importSelectedQuiz;
        window.copyJoinUrl = copyJoinUrl;
        window.updateModalOptions = updateModalOptions;
    </script>
</body>
</html>