<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Session Display - IntellaClick</title>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #4F46E5;
            --secondary-color: #10B981;
            --danger-color: #EF4444;
            --text-primary: #1F2937;
            --text-secondary: #6B7280;
            --border: #E5E7EB;
            --background: #F3F4F6;
            --surface: #FFFFFF;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            position: relative;
        }

        /* Session Info Card */
        .session-info-card {
            position: fixed;
            top: 1.5rem;
            left: 1.5rem;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 1.5rem;
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            max-width: 240px;
            z-index: 100;
            transition: opacity 0.3s, transform 0.3s;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .session-info-card.hidden {
            opacity: 0;
            transform: translateX(-100%);
            pointer-events: none;
        }

        .session-code-display {
            text-align: center;
            margin-bottom: 1rem;
        }

        .session-code-label {
            font-size: 0.875rem;
            color: #666;
            margin-bottom: 0.25rem;
        }

        .session-code {
            font-size: 2.5rem;
            font-weight: bold;
            color: var(--primary-color);
            letter-spacing: 0.1em;
        }

        .join-url {
            font-size: 0.75rem;
            color: #666;
            margin-top: 0.5rem;
            word-break: break-all;
        }

        .qr-code-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(248, 249, 250, 0.8);
            border-radius: 12px;
        }

        #qrcode {
            max-width: 200px;
        }

        /* Question Display Area */
        .question-area {
            position: fixed;
            top: 1.5rem;
            left: calc(1.5rem + 240px + 1.5rem);
            right: calc(1.5rem + 380px + 1.5rem);
            z-index: 50;
            transition: opacity 0.3s, left 0.3s, right 0.3s;
        }

        .question-area.full-width {
            left: 1.5rem;
            right: 1.5rem;
        }

        .question-area.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .question-card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 24px;
            padding: 2.5rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }

        .question-number {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .timer {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1.5rem;
            font-weight: bold;
            color: #e74c3c;
        }

        .timer.warning {
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .question-text {
            font-size: 1.75rem;
            line-height: 1.4;
            text-align: center;
            margin-bottom: 2rem;
            color: var(--text-primary);
        }

        .options-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
        }

        .option {
            background: rgba(248, 249, 250, 0.8);
            border: 2px solid rgba(233, 236, 239, 0.8);
            padding: 1.25rem 1.25rem 1.25rem 4rem;
            border-radius: 16px;
            text-align: left;
            font-size: 1.125rem;
            transition: all 0.3s;
            position: relative;
            min-height: 70px;
            display: flex;
            align-items: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .option-label {
            position: absolute;
            top: 50%;
            left: 0.75rem;
            transform: translateY(-50%);
            width: 2.75rem;
            height: 2.75rem;
            background: var(--primary-color);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.25rem;
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.3);
        }

        .option-text {
            flex: 1;
        }

        .option.true-false {
            grid-column: span 2;
            justify-content: center;
        }

        .option.true-false .option-text {
            margin-left: 3.5rem;
            font-size: 1.5rem;
        }

        .option.correct {
            background: #d4edda;
            border-color: #28a745;
            animation: correctPulse 0.5s ease;
        }

        .option.correct .option-label {
            background: #28a745;
        }

        @keyframes correctPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        /* Analytics Panel */
        .analytics-panel {
            position: fixed;
            top: 1.5rem;
            right: 1.5rem;
            width: 380px;
            max-height: calc(100vh - 120px);
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            z-index: 100;
            transition: opacity 0.3s, transform 0.3s;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .analytics-panel.hidden {
            opacity: 0;
            transform: translateX(100%);
            pointer-events: none;
        }

        .analytics-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .analytics-title {
            font-size: 1.25rem;
            font-weight: bold;
            color: var(--text-primary);
        }

        .response-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-bottom: 1.5rem;
            padding: 1.25rem;
            background: rgba(248, 249, 250, 0.6);
            border-radius: 12px;
        }

        .stat {
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: var(--primary-color);
        }

        .stat-label {
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
        }

        .response-chart {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .response-bar {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .response-option {
            width: 2.5rem;
            height: 2.5rem;
            background: var(--primary-color);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            flex-shrink: 0;
        }

        .response-bar-container {
            flex: 1;
            background: #e9ecef;
            height: 2.5rem;
            border-radius: 1.25rem;
            overflow: hidden;
            position: relative;
        }

        .response-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), #667eea);
            border-radius: 1.25rem;
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 0.75rem;
            position: relative;
            overflow: hidden;
        }

        .response-bar-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .response-count {
            color: white;
            font-weight: bold;
            font-size: 0.875rem;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        .response-percent {
            margin-left: 0.5rem;
            font-weight: bold;
            color: var(--text-primary);
            font-size: 0.875rem;
        }

        /* Control Bar */
        .control-bar {
            position: fixed;
            bottom: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            padding: 1rem 2rem;
            z-index: 100;
            transition: opacity 0.3s, transform 0.3s;
        }

        .control-bar.hidden {
            opacity: 0;
            transform: translateX(-50%) translateY(150%);
            pointer-events: none;
        }

        .control-section {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-primary {
            background: var(--primary-color);
            color: white;
        }

        .btn-primary:hover {
            background: #4338CA;
        }

        .btn-success {
            background: var(--secondary-color);
            color: white;
        }

        .btn-success:hover {
            background: #059669;
        }

        .btn-danger {
            background: var(--danger-color);
            color: white;
        }

        .btn-danger:hover {
            background: #DC2626;
        }

        .btn-secondary {
            background: #E5E7EB;
            color: var(--text-primary);
        }

        .btn-secondary:hover {
            background: #D1D5DB;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Settings Button */
        .settings-btn {
            position: fixed;
            top: 1.5rem;
            right: calc(1.5rem + 380px + 1rem);
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            width: 56px;
            height: 56px;
            border-radius: 50%;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            transition: all 0.3s;
            z-index: 101;
        }

        .settings-btn:hover {
            transform: rotate(90deg) scale(1.1);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
        }

        /* Settings Panel */
        .settings-panel {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100vh;
            background: white;
            box-shadow: -4px 0 20px rgba(0, 0, 0, 0.3);
            transition: right 0.3s;
            z-index: 200;
            overflow-y: auto;
        }

        .settings-panel.open {
            right: 0;
        }

        .settings-header {
            background: var(--primary-color);
            color: white;
            padding: 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .settings-title {
            font-size: 1.25rem;
            font-weight: 600;
        }

        .close-settings {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
        }

        .settings-body {
            padding: 1.5rem;
        }

        .setting-group {
            margin-bottom: 2rem;
        }

        .setting-group-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--border);
        }

        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 0;
        }

        .setting-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        /* Toggle Switch */
        .toggle-switch {
            position: relative;
            width: 48px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.3s;
            border-radius: 24px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: var(--primary-color);
        }

        input:checked + .toggle-slider:before {
            transform: translateX(24px);
        }

        .waiting-message {
            text-align: center;
            padding: 4rem 2rem;
            color: white;
            font-size: 1.5rem;
        }

        .waiting-message .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255,255,255,0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- Settings Button -->
    <button class="settings-btn" onclick="toggleSettings()">
        ‚öôÔ∏è
    </button>

    <!-- Session Info Card -->
    <div class="session-info-card" id="sessionInfo">
        <div class="session-code-display">
            <div class="session-code-label">Session Code</div>
            <div class="session-code" id="sessionCode">Loading...</div>
            <div class="join-url" id="joinUrl">join.intellaclick.com</div>
        </div>
        <div class="qr-code-container" id="qrCodeContainer">
            <div id="qrcode"></div>
        </div>
    </div>

    <!-- Question Display -->
    <div class="question-area" id="questionArea">
        <div id="waitingMessage" class="waiting-message">
            <div class="spinner"></div>
            <div>Waiting for question...</div>
        </div>

        <div class="question-card" id="questionCard" style="display: none;">
            <div class="question-header">
                <div class="question-number" id="questionNumber">Question 1</div>
                <div class="timer" id="timer">
                    <span>‚è±Ô∏è</span>
                    <span id="timeLeft">30</span>
                </div>
            </div>

            <div class="question-text" id="questionText"></div>

            <div class="options-grid" id="optionsGrid"></div>
        </div>
    </div>

    <!-- Analytics Panel -->
    <div class="analytics-panel" id="analyticsPanel">
        <div class="analytics-header">
            <div class="analytics-title">Live Results</div>
        </div>

        <div class="response-stats">
            <div class="stat">
                <div class="stat-value" id="responseCount">0</div>
                <div class="stat-label">Responses</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="participantCount">0</div>
                <div class="stat-label">Participants</div>
            </div>
        </div>

        <div class="response-chart" id="responseChart"></div>
    </div>

    <!-- Control Bar -->
    <div class="control-bar" id="controlBar">
        <button class="btn btn-secondary" onclick="window.location.href='/session.html?id=' + sessionId + '&code=' + sessionCode">
            ‚Üê Back
        </button>

        <button class="btn btn-primary" onclick="sendNextQuestion()" id="nextQuestionBtn" style="font-size: 1.125rem; padding: 1rem 2rem;">
            ‚ñ∂ Next Question
        </button>

        <button class="btn btn-success" onclick="addTime(10)" id="addTimeBtn" disabled>
            + 10s
        </button>

        <button class="btn btn-success" onclick="addTime(30)" id="addTime30Btn" disabled>
            + 30s
        </button>

        <button class="btn btn-danger" onclick="endQuestion()" id="endBtn" disabled>
            End Question
        </button>
    </div>

    <!-- Settings Panel -->
    <div class="settings-panel" id="settingsPanel">
        <div class="settings-header">
            <div class="settings-title">Display Settings</div>
            <button class="close-settings" onclick="toggleSettings()">√ó</button>
        </div>

        <div class="settings-body">
            <div class="setting-group">
                <div class="setting-group-title">Session Information</div>
                <div class="setting-item">
                    <span class="setting-label">Show Session Code & QR</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="showSessionInfo" checked onchange="applySettings()">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>

            <div class="setting-group">
                <div class="setting-group-title">Question Display</div>
                <div class="setting-item">
                    <span class="setting-label">Show Question Text</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="showQuestion" checked onchange="applySettings()">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="setting-item">
                    <span class="setting-label">Show Timer</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="showTimer" checked onchange="applySettings()">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>

            <div class="setting-group">
                <div class="setting-group-title">Live Analytics</div>
                <div class="setting-item">
                    <span class="setting-label">Show Analytics Panel</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="showAnalytics" checked onchange="applySettings()">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>

            <div class="setting-group">
                <div class="setting-group-title">Controls</div>
                <div class="setting-item">
                    <span class="setting-label">Show Control Bar</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="showControls" checked onchange="applySettings()">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>

            <div class="setting-group">
                <div class="setting-group-title">Question End Behavior</div>
                <div class="setting-item">
                    <span class="setting-label">Show Correct Answer</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="showCorrectAnswer" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="setting-item">
                    <span class="setting-label">Keep Results on Screen</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="keepResults" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>

            <div class="setting-group">
                <div class="setting-group-title">Session Questions</div>
                <div style="padding: 0.5rem 0;">
                    <button class="btn btn-primary" onclick="saveSessionQuestions()" style="width: 100%; margin-bottom: 0.5rem;">
                        üíæ Save Questions for Reuse
                    </button>
                    <p style="font-size: 0.75rem; color: var(--text-secondary); margin: 0;">
                        Save current question queue to use in future sessions
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script>
        let sessionId;
        let sessionCode;
        let socket;
        let currentQuestion = null;
        let timerInterval = null;
        let timeRemaining = 0;
        let questionEnded = false; // Track if we manually ended the question

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            const urlParams = new URLSearchParams(window.location.search);
            sessionId = urlParams.get('id');
            sessionCode = urlParams.get('code');

            if (!sessionId || !sessionCode) {
                alert('Invalid session parameters');
                window.location.href = '/classes.html';
                return;
            }

            document.getElementById('sessionCode').textContent = sessionCode;
            document.getElementById('joinUrl').textContent = `join.intellaclick.com/session/${sessionCode}`;

            // Generate QR code
            new QRCode(document.getElementById('qrcode'), {
                text: `https://join.intellaclick.com/session/${sessionCode}`,
                width: 180,
                height: 180
            });

            // Connect to Socket.IO
            connectSocket();

            // Poll for updates - every 1 second for real-time feel
            setInterval(pollSession, 1000);
            pollSession();
        });

        function connectSocket() {
            try {
                socket = io('https://api.intellaclick.com', {
                    transports: ['websocket', 'polling'],
                    reconnection: true,
                    reconnectionDelay: 1000,
                    reconnectionAttempts: 5
                });

                socket.on('connect', () => {
                    console.log('Connected to Socket.IO');
                    socket.emit('join-session', { sessionCode });
                });

                socket.on('connect_error', (error) => {
                    console.log('Socket connection error (will retry):', error.message);
                });

                socket.on('question-sent', (data) => {
                    console.log('New question received:', data);
                    displayQuestion(data.question);
                });

                socket.on('response-update', (data) => {
                    console.log('Response update received:', data);
                    updateAnalytics(data);
                    // Force immediate poll to get latest data
                    pollSession();
                });

                socket.on('new-response', (data) => {
                    console.log('New response received:', data);
                    // Force immediate poll to get latest data
                    pollSession();
                });

                socket.on('question-ended', () => {
                    console.log('Question ended');
                    if (timerInterval) {
                        clearInterval(timerInterval);
                    }
                });
            } catch (error) {
                console.error('Failed to initialize socket:', error);
                // Continue without socket - polling will still work
            }
        }

        async function pollSession() {
            try {
                // Fetch current question (no auth needed - public endpoint)
                const questionResponse = await fetch(`https://api.intellaclick.com/api/sessions/code/${sessionCode}/current-question`, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json'
                    }
                });

                if (!questionResponse.ok) {
                    console.error('Failed to fetch question:', questionResponse.status);
                    return;
                }

                const questionData = await questionResponse.json();

                if (questionData.question) {
                    // New question available
                    questionEnded = false; // Reset the flag
                    if (!currentQuestion || currentQuestion.id !== questionData.question.id) {
                        displayQuestion(questionData.question);
                    }
                } else {
                    // No current question - only show waiting if we're not keeping results
                    const keepResults = document.getElementById('keepResults').checked;
                    if (!questionEnded || !keepResults) {
                        showWaiting();
                    }
                }

                // Fetch session info (no auth needed - public endpoint)
                const sessionResponse = await fetch(`https://api.intellaclick.com/api/sessions/code/${sessionCode}`, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json'
                    }
                });

                if (!sessionResponse.ok) {
                    console.error('Failed to fetch session:', sessionResponse.status);
                    return;
                }

                const sessionData = await sessionResponse.json();
                if (sessionData.session) {
                    document.getElementById('participantCount').textContent = sessionData.session.participantCount || 0;

                    // Update response count and chart if there's a current question
                    if (currentQuestion && sessionData.session.responses) {
                        console.log('Current question ID:', currentQuestion.id);
                        console.log('All responses:', sessionData.session.responses);

                        const questionResponses = sessionData.session.responses.filter(r => {
                            console.log('Checking response:', r, 'questionId:', r.questionId);
                            return r.questionId === currentQuestion.id || r.questionId === currentQuestion.questionId;
                        });

                        console.log('Filtered responses for current question:', questionResponses);
                        document.getElementById('responseCount').textContent = questionResponses.length;
                        updateResponseChart(questionResponses);
                    }
                }
            } catch (error) {
                console.error('Error polling session:', error);
                // Don't show error to user, just log it and retry on next poll
            }
        }

        function displayQuestion(question) {
            currentQuestion = question;
            questionEnded = false; // Reset the ended flag for new question

            console.log('=== DISPLAYING QUESTION ===');
            console.log('Full question object:', JSON.stringify(question, null, 2));
            console.log('Question type:', question.type, question.questionType);
            console.log('Has pairs?', !!question.pairs, question.pairs);
            console.log('Has leftColumn?', !!question.leftColumn, question.leftColumn);
            console.log('Has rightColumn?', !!question.rightColumn, question.rightColumn);
            console.log('Has items?', !!question.items, question.items);
            console.log('Has correctOrder?', !!question.correctOrder, question.correctOrder);
            console.log('========================');

            // Hide waiting, show question
            document.getElementById('waitingMessage').style.display = 'none';
            document.getElementById('questionCard').style.display = 'block';

            // Set question text
            document.getElementById('questionText').textContent = question.questionText;

            // Set question number (if available)
            document.getElementById('questionNumber').textContent = `Question ${question.questionNumber || 1}`;

            // Display options based on question type
            const optionsGrid = document.getElementById('optionsGrid');
            optionsGrid.innerHTML = '';

            const questionType = question.type || question.questionType;

            if (questionType === 'ordering') {
                // For ordering questions, show items to be ordered
                // Check for items, correctOrder, or options
                const itemsToDisplay = question.items || question.correctOrder || question.options || [];

                if (itemsToDisplay.length > 0) {
                    itemsToDisplay.forEach((item, index) => {
                        const optionDiv = document.createElement('div');
                        optionDiv.className = 'option';
                        const optionText = typeof item === 'string' ? item : (item.text || item);
                        const optionLetter = String.fromCharCode(65 + index);
                        optionDiv.innerHTML = `
                            <div class="option-label">${optionLetter}</div>
                            <div class="option-text">${optionText}</div>
                        `;
                        optionsGrid.appendChild(optionDiv);
                    });
                }
            } else if (questionType === 'matching') {
                // For matching questions - handle both formats
                if (question.pairs && Array.isArray(question.pairs)) {
                    // Format: pairs: [{ left, right }]
                    const matchDiv = document.createElement('div');
                    matchDiv.style.display = 'grid';
                    matchDiv.style.gridTemplateColumns = '1fr 1fr';
                    matchDiv.style.gap = '2rem';

                    const leftCol = document.createElement('div');
                    const rightCol = document.createElement('div');

                    const leftItems = question.pairs.map(p => p.left);
                    const rightItems = question.pairs.map(p => p.right);

                    leftCol.innerHTML = '<h3 style="margin-bottom: 1rem;">Match:</h3>' +
                        leftItems.map((item, i) =>
                            `<div style="padding: 0.75rem; margin-bottom: 0.5rem; background: rgba(248,249,250,0.8); border-radius: 8px;">
                                ${String.fromCharCode(65 + i)}. ${item}
                            </div>`
                        ).join('');

                    rightCol.innerHTML = '<h3 style="margin-bottom: 1rem;">With:</h3>' +
                        rightItems.map((item, i) =>
                            `<div style="padding: 0.75rem; margin-bottom: 0.5rem; background: rgba(248,249,250,0.8); border-radius: 8px;">
                                ${i + 1}. ${item}
                            </div>`
                        ).join('');

                    matchDiv.appendChild(leftCol);
                    matchDiv.appendChild(rightCol);
                    optionsGrid.appendChild(matchDiv);
                } else if (question.leftColumn && question.rightColumn) {
                    // Alternative format: leftColumn[], rightColumn[]
                    const matchDiv = document.createElement('div');
                    matchDiv.style.display = 'grid';
                    matchDiv.style.gridTemplateColumns = '1fr 1fr';
                    matchDiv.style.gap = '2rem';

                    const leftCol = document.createElement('div');
                    const rightCol = document.createElement('div');

                    leftCol.innerHTML = '<h3 style="margin-bottom: 1rem;">Match:</h3>' +
                        question.leftColumn.map((item, i) =>
                            `<div style="padding: 0.75rem; margin-bottom: 0.5rem; background: rgba(248,249,250,0.8); border-radius: 8px;">
                                ${String.fromCharCode(65 + i)}. ${item}
                            </div>`
                        ).join('');

                    rightCol.innerHTML = '<h3 style="margin-bottom: 1rem;">With:</h3>' +
                        question.rightColumn.map((item, i) =>
                            `<div style="padding: 0.75rem; margin-bottom: 0.5rem; background: rgba(248,249,250,0.8); border-radius: 8px;">
                                ${i + 1}. ${item}
                            </div>`
                        ).join('');

                    matchDiv.appendChild(leftCol);
                    matchDiv.appendChild(rightCol);
                    optionsGrid.appendChild(matchDiv);
                }
            } else if (questionType === 'fill_blank' || questionType === 'fillblank') {
                // For fill blank, show instruction
                const infoDiv = document.createElement('div');
                infoDiv.style.textAlign = 'center';
                infoDiv.style.color = 'var(--text-secondary)';
                infoDiv.style.fontStyle = 'italic';
                infoDiv.style.padding = '2rem';
                infoDiv.textContent = 'Students will type their answer where [blank] appears';
                optionsGrid.appendChild(infoDiv);
            } else {
                // Standard multiple choice or true/false
                if (question.options && question.options.length > 0) {
                    question.options.forEach((option, index) => {
                        const optionDiv = document.createElement('div');
                        optionDiv.className = 'option';
                        if (question.type === 'boolean' || question.type === 'true_false') {
                            optionDiv.classList.add('true-false');
                        }

                        const optionText = typeof option === 'string' ? option : option.text;
                        const optionLetter = String.fromCharCode(65 + index);

                        optionDiv.innerHTML = `
                            <div class="option-label">${optionLetter}</div>
                            <div class="option-text">${optionText}</div>
                        `;

                        optionsGrid.appendChild(optionDiv);
                    });
                }
            }

            // Start timer
            if (question.timeLimit) {
                startTimer(question.timeLimit, question.startedAt);
            }

            // Enable controls
            document.getElementById('addTimeBtn').disabled = false;
            document.getElementById('addTime30Btn').disabled = false;
            document.getElementById('endBtn').disabled = false;

            // Reset analytics
            document.getElementById('responseCount').textContent = '0';
            updateResponseChart([]);
        }

        function showWaiting() {
            currentQuestion = null;
            document.getElementById('waitingMessage').style.display = 'block';
            document.getElementById('questionCard').style.display = 'none';

            if (timerInterval) {
                clearInterval(timerInterval);
            }

            // Disable controls
            document.getElementById('addTimeBtn').disabled = true;
            document.getElementById('addTime30Btn').disabled = true;
            document.getElementById('endBtn').disabled = true;
        }

        function startTimer(duration, startedAt) {
            if (timerInterval) {
                clearInterval(timerInterval);
            }

            const start = new Date(startedAt);
            const end = new Date(start.getTime() + duration * 1000);

            timerInterval = setInterval(() => {
                const now = new Date();
                timeRemaining = Math.max(0, Math.floor((end - now) / 1000));

                document.getElementById('timeLeft').textContent = timeRemaining;

                const timerEl = document.getElementById('timer');
                if (timeRemaining <= 10) {
                    timerEl.classList.add('warning');
                } else {
                    timerEl.classList.remove('warning');
                }

                if (timeRemaining <= 0) {
                    clearInterval(timerInterval);
                }
            }, 100);
        }

        function updateAnalytics(data) {
            if (!data) return;

            document.getElementById('responseCount').textContent = data.responseCount || 0;

            if (data.responses) {
                updateResponseChart(data.responses);
            }
        }

        function updateResponseChart(responses) {
            const chartContainer = document.getElementById('responseChart');
            chartContainer.innerHTML = '';

            if (!currentQuestion) return;

            console.log('Updating chart with responses:', responses);
            console.log('Current question type:', currentQuestion.type);
            console.log('Current question options:', currentQuestion.options);

            const questionType = currentQuestion.type || currentQuestion.questionType;

            // Handle different question types
            if (questionType === 'fill_blank' || questionType === 'fillblank') {
                renderFillBlankResponses(responses, chartContainer);
            } else if (questionType === 'matching') {
                renderMatchingResponses(responses, chartContainer);
            } else if (questionType === 'ordering') {
                renderOrderingResponses(responses, chartContainer);
            } else {
                // Multiple choice, true/false - use bar chart
                renderBarChart(responses, chartContainer);
            }
        }

        function renderBarChart(responses, container) {
            if (!currentQuestion.options) return;

            // Count responses per option - handle both letter-based (A, B) and text-based (True, False)
            const counts = {};
            currentQuestion.options.forEach((option, index) => {
                const letter = String.fromCharCode(65 + index);
                const optionText = typeof option === 'string' ? option : (option.text || option.id);

                counts[index] = {
                    letter: letter,
                    text: optionText,
                    count: 0
                };
            });

            console.log('Initialized counts:', counts);

            responses.forEach(response => {
                console.log('Processing response:', response.answer);

                // Try to match by letter (A, B, C), by text (True, False), or by index
                for (let i = 0; i < currentQuestion.options.length; i++) {
                    const letter = String.fromCharCode(65 + i);
                    const optionText = typeof currentQuestion.options[i] === 'string'
                        ? currentQuestion.options[i]
                        : (currentQuestion.options[i].text || currentQuestion.options[i].id);

                    if (response.answer === letter ||
                        response.answer === optionText ||
                        response.answer === optionText.toLowerCase() ||
                        response.answer === optionText.toUpperCase()) {
                        counts[i].count++;
                        console.log(`Matched answer "${response.answer}" to option ${i} (${optionText})`);
                        break;
                    }
                }
            });

            console.log('Final counts:', counts);

            const total = responses.length || 1;

            // Render bars
            Object.values(counts).forEach(item => {
                const percent = Math.round((item.count / total) * 100);

                const bar = document.createElement('div');
                bar.className = 'response-bar';
                bar.innerHTML = `
                    <div class="response-option">${item.letter}</div>
                    <div class="response-bar-container">
                        <div class="response-bar-fill" style="width: ${percent}%">
                            ${item.count > 0 ? `<span class="response-count">${item.count}</span>` : ''}
                        </div>
                    </div>
                    <span class="response-percent">${percent}%</span>
                `;
                container.appendChild(bar);
            });
        }

        function renderFillBlankResponses(responses, container) {
            const title = document.createElement('div');
            title.style.fontWeight = '600';
            title.style.marginBottom = '1rem';
            title.style.color = 'var(--text-primary)';
            title.textContent = 'Student Responses:';
            container.appendChild(title);

            if (responses.length === 0) {
                const empty = document.createElement('div');
                empty.style.color = 'var(--text-secondary)';
                empty.style.fontStyle = 'italic';
                empty.textContent = 'No responses yet';
                container.appendChild(empty);
                return;
            }

            responses.forEach((response, idx) => {
                const responseDiv = document.createElement('div');
                responseDiv.style.padding = '0.75rem';
                responseDiv.style.marginBottom = '0.5rem';
                responseDiv.style.background = 'rgba(248, 249, 250, 0.6)';
                responseDiv.style.borderRadius = '8px';
                responseDiv.style.fontSize = '0.9rem';
                responseDiv.innerHTML = `<strong>${idx + 1}.</strong> ${response.answer}`;
                container.appendChild(responseDiv);
            });
        }

        function renderMatchingResponses(responses, container) {
            const title = document.createElement('div');
            title.style.fontWeight = '600';
            title.style.marginBottom = '1rem';
            title.style.color = 'var(--text-primary)';
            title.textContent = 'Student Matches:';
            container.appendChild(title);

            if (responses.length === 0) {
                const empty = document.createElement('div');
                empty.style.color = 'var(--text-secondary)';
                empty.style.fontStyle = 'italic';
                empty.textContent = 'No responses yet';
                container.appendChild(empty);
                return;
            }

            responses.forEach((response, idx) => {
                const responseDiv = document.createElement('div');
                responseDiv.style.padding = '0.75rem';
                responseDiv.style.marginBottom = '0.5rem';
                responseDiv.style.background = 'rgba(248, 249, 250, 0.6)';
                responseDiv.style.borderRadius = '8px';
                responseDiv.style.fontSize = '0.9rem';

                // Try to parse and display matching pairs
                let displayText = response.answer;
                try {
                    const matches = JSON.parse(response.answer);
                    if (Array.isArray(matches)) {
                        displayText = matches.map(m => `${m.left} ‚Üí ${m.right}`).join(', ');
                    }
                } catch (e) {
                    // If not JSON, display as-is
                }

                responseDiv.innerHTML = `<strong>${idx + 1}.</strong> ${displayText}`;
                container.appendChild(responseDiv);
            });
        }

        function renderOrderingResponses(responses, container) {
            const title = document.createElement('div');
            title.style.fontWeight = '600';
            title.style.marginBottom = '1rem';
            title.style.color = 'var(--text-primary)';
            title.textContent = 'Student Order:';
            container.appendChild(title);

            if (responses.length === 0) {
                const empty = document.createElement('div');
                empty.style.color = 'var(--text-secondary)';
                empty.style.fontStyle = 'italic';
                empty.textContent = 'No responses yet';
                container.appendChild(empty);
                return;
            }

            responses.forEach((response, idx) => {
                const responseDiv = document.createElement('div');
                responseDiv.style.padding = '0.75rem';
                responseDiv.style.marginBottom = '0.5rem';
                responseDiv.style.background = 'rgba(248, 249, 250, 0.6)';
                responseDiv.style.borderRadius = '8px';
                responseDiv.style.fontSize = '0.9rem';

                // Format ordering response (usually comma-separated or array)
                let displayText = response.answer;
                try {
                    const order = JSON.parse(response.answer);
                    if (Array.isArray(order)) {
                        displayText = order.join(' ‚Üí ');
                    }
                } catch (e) {
                    // If not JSON, check if comma-separated
                    if (typeof response.answer === 'string' && response.answer.includes(',')) {
                        displayText = response.answer.split(',').join(' ‚Üí ');
                    }
                }

                responseDiv.innerHTML = `<strong>${idx + 1}.</strong> ${displayText}`;
                container.appendChild(responseDiv);
            });
        }

        async function addTime(seconds) {
            if (!currentQuestion) return;

            try {
                const response = await fetch(`https://api.intellaclick.com/api/sessions/${sessionId}/questions/${currentQuestion.id}/timer`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    },
                    body: JSON.stringify({ addSeconds: seconds })
                });

                if (response.ok) {
                    timeRemaining += seconds;
                }
            } catch (error) {
                console.error('Error adding time:', error);
            }
        }

        async function endQuestion() {
            if (!currentQuestion) return;

            try {
                const response = await fetch(`https://api.intellaclick.com/api/sessions/${sessionId}/questions/${currentQuestion.id}/end`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    }
                });

                if (response.ok) {
                    questionEnded = true; // Mark that we ended the question
                    const keepResults = document.getElementById('keepResults').checked;

                    if (!keepResults) {
                        showWaiting();
                    } else {
                        // Keep results visible, just stop the timer
                        if (timerInterval) {
                            clearInterval(timerInterval);
                        }
                        // Disable timer controls
                        document.getElementById('addTimeBtn').disabled = true;
                        document.getElementById('addTime30Btn').disabled = true;
                        document.getElementById('endBtn').disabled = true;

                        // Show correct answer if setting is enabled
                        const showCorrect = document.getElementById('showCorrectAnswer').checked;
                        if (showCorrect && currentQuestion.correctAnswer) {
                            highlightCorrectAnswer();
                        }
                    }
                }
            } catch (error) {
                console.error('Error ending question:', error);
            }
        }

        function highlightCorrectAnswer() {
            if (!currentQuestion || !currentQuestion.correctAnswer) {
                console.log('Cannot highlight - no question or no correct answer');
                return;
            }

            const questionType = currentQuestion.type || currentQuestion.questionType;

            // Only highlight for MCQ and True/False
            if (questionType === 'fill_blank' || questionType === 'fillblank' ||
                questionType === 'matching' || questionType === 'ordering') {
                console.log('Skipping highlight for question type:', questionType);
                return;
            }

            console.log('Highlighting correct answer:', currentQuestion.correctAnswer);
            console.log('Question options:', currentQuestion.options);

            const optionsGrid = document.getElementById('optionsGrid');
            const options = optionsGrid.querySelectorAll('.option');

            // Find and highlight the correct answer
            options.forEach((optionEl, index) => {
                const optionLetter = String.fromCharCode(65 + index);
                const optionText = typeof currentQuestion.options[index] === 'string'
                    ? currentQuestion.options[index]
                    : (currentQuestion.options[index].text || currentQuestion.options[index].id);

                const correctAnswerUpper = String(currentQuestion.correctAnswer).toUpperCase();
                const optionTextUpper = String(optionText).toUpperCase();

                console.log(`Checking option ${index}: letter=${optionLetter}, text=${optionText}, correct=${currentQuestion.correctAnswer}`);

                // Check if this is the correct answer - match by letter OR by text
                if (optionLetter === correctAnswerUpper ||
                    optionTextUpper === correctAnswerUpper ||
                    optionText === currentQuestion.correctAnswer) {
                    console.log(`Match found! Highlighting option ${index}`);
                    optionEl.classList.add('correct');
                }
            });
        }

        function toggleSettings() {
            document.getElementById('settingsPanel').classList.toggle('open');
        }

        let questionQueue = [];
        let currentQuestionIndex = -1;

        async function sendNextQuestion() {
            try {
                const token = localStorage.getItem('token');
                if (!token) {
                    alert('Please log in first');
                    return;
                }

                // Load question queue from sessionStorage (shared with session.html)
                const queueData = sessionStorage.getItem('questionQueue_' + sessionCode);
                const indexData = sessionStorage.getItem('questionIndex_' + sessionCode);

                if (queueData) {
                    questionQueue = JSON.parse(queueData);
                    currentQuestionIndex = indexData ? parseInt(indexData) : -1;
                }

                // Check if there are questions in the queue
                if (!questionQueue || questionQueue.length === 0) {
                    alert('No questions in queue. Add questions from the session page first.');
                    return;
                }

                if (currentQuestionIndex + 1 >= questionQueue.length) {
                    alert('No more questions in queue.');
                    return;
                }

                currentQuestionIndex++;
                const question = questionQueue[currentQuestionIndex];

                // Normalize question type for student interface compatibility
                const normalizedQuestion = {...question};

                // Remove the original 'type' field to avoid confusion
                delete normalizedQuestion.type;

                // Map our types to what the student interface expects
                const typeMap = {
                    'mcq': 'multiple_choice',
                    'tf': 'boolean',
                    'matching': 'matching',
                    'ordering': 'ordering',
                    'fillblank': 'fill_blank'
                };

                // Set both questionType and type to the mapped value
                const mappedType = typeMap[question.type] || question.type;
                normalizedQuestion.questionType = mappedType;
                normalizedQuestion.type = mappedType;

                // Ensure questionText is set
                normalizedQuestion.questionText = question.text || question.questionText;

                // For true/false, ensure options are properly formatted
                if (question.type === 'tf') {
                    normalizedQuestion.options = ['True', 'False'];
                }

                // For matching questions, convert pairs format to left/right columns
                if (question.type === 'matching') {
                    if (question.pairs && Array.isArray(question.pairs)) {
                        // Convert pairs to separate columns
                        normalizedQuestion.leftColumn = question.pairs.map(p => p.left);
                        normalizedQuestion.rightColumn = question.pairs.map(p => p.right);
                        normalizedQuestion.pairs = question.pairs; // Keep pairs too
                    } else if (question.leftColumn && question.rightColumn) {
                        normalizedQuestion.leftColumn = question.leftColumn;
                        normalizedQuestion.rightColumn = question.rightColumn;
                    }
                    if (question.correctPairs) normalizedQuestion.correctPairs = question.correctPairs;
                }

                // For ordering questions, ensure items field is present
                if (question.type === 'ordering') {
                    // Send as items (what display expects) and also correctOrder (what was saved)
                    if (question.correctOrder) {
                        normalizedQuestion.items = question.correctOrder;
                        normalizedQuestion.correctOrder = question.correctOrder;
                    } else if (question.items) {
                        normalizedQuestion.items = question.items;
                        normalizedQuestion.correctOrder = question.items;
                    }
                }

                console.log('Sending question to backend:', normalizedQuestion);

                // Send the question
                const response = await fetch(`https://api.intellaclick.com/api/sessions/${sessionId}/questions`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify(normalizedQuestion)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Failed to send question');
                }

                // Save updated index
                sessionStorage.setItem('questionIndex_' + sessionCode, currentQuestionIndex.toString());

                // Update button state
                document.getElementById('nextQuestionBtn').disabled = (currentQuestionIndex + 1 >= questionQueue.length);

                // Question will be displayed via polling/socket
            } catch (error) {
                console.error('Error sending question:', error);
                alert('Failed to send question: ' + error.message);
            }
        }

        function saveSessionQuestions() {
            // Load current question queue
            const queueData = sessionStorage.getItem('questionQueue_' + sessionCode);

            if (!queueData) {
                alert('No questions to save. Add questions to the session first.');
                return;
            }

            const questions = JSON.parse(queueData);

            if (questions.length === 0) {
                alert('No questions to save.');
                return;
            }

            // Prompt for template name
            const templateName = prompt('Enter a name for this question set:', `Session ${sessionCode} Questions`);

            if (!templateName) return; // User cancelled

            // Load existing saved question sets
            const savedSets = JSON.parse(localStorage.getItem('savedQuestionSets') || '[]');

            // Add new set
            const newSet = {
                id: 'qset_' + Date.now(),
                name: templateName,
                questions: questions,
                createdAt: new Date().toISOString(),
                questionCount: questions.length
            };

            savedSets.push(newSet);

            // Save to localStorage
            localStorage.setItem('savedQuestionSets', JSON.stringify(savedSets));

            alert(`‚úÖ Saved "${templateName}" with ${questions.length} questions!\n\nYou can load this question set from the session creation page.`);

            // Close settings panel
            document.getElementById('settingsPanel').classList.remove('open');
        }

        function applySettings() {
            const showSessionInfo = document.getElementById('showSessionInfo').checked;
            const showQuestion = document.getElementById('showQuestion').checked;
            const showTimer = document.getElementById('showTimer').checked;
            const showAnalytics = document.getElementById('showAnalytics').checked;
            const showControls = document.getElementById('showControls').checked;

            document.getElementById('sessionInfo').classList.toggle('hidden', !showSessionInfo);
            document.getElementById('questionArea').classList.toggle('hidden', !showQuestion);
            document.getElementById('timer').style.visibility = showTimer ? 'visible' : 'hidden';
            document.getElementById('analyticsPanel').classList.toggle('hidden', !showAnalytics);
            document.getElementById('controlBar').classList.toggle('hidden', !showControls);

            // Adjust question area positioning based on what's visible
            const questionArea = document.getElementById('questionArea');
            if (!showSessionInfo && !showAnalytics) {
                // Both panels hidden - full width
                questionArea.style.left = '1.5rem';
                questionArea.style.right = '1.5rem';
            } else if (!showSessionInfo) {
                // Only session info hidden - expand to left
                questionArea.style.left = '1.5rem';
                questionArea.style.right = 'calc(1.5rem + 380px + 1.5rem)';
            } else if (!showAnalytics) {
                // Only analytics hidden - expand to right
                questionArea.style.left = 'calc(1.5rem + 240px + 1.5rem)';
                questionArea.style.right = '1.5rem';
            } else {
                // Both visible - normal spacing
                questionArea.style.left = 'calc(1.5rem + 240px + 1.5rem)';
                questionArea.style.right = 'calc(1.5rem + 380px + 1.5rem)';
            }
        }
    </script>
</body>
</html>
