<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Session Management - IntellaClick</title>
    <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.1/build/qrcode.min.js"></script>
    <!-- Modular CSS -->
    <link rel="stylesheet" href="../styles/common.css">
    <link rel="stylesheet" href="../styles/session.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Session Management</h1>
            <div class="session-info">
                <div class="info-item">
                    <span class="info-label">Session Code</span>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span class="session-code" id="sessionCode">Loading...</span>
                        <button class="btn btn-secondary" onclick="copySessionCode()" style="padding: 4px 8px; font-size: 12px;">Copy</button>
                    </div>
                </div>
                <div class="info-item">
                    <span class="info-label">Status</span>
                    <span class="status-badge status-waiting" id="sessionStatus">Waiting</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Participants</span>
                    <span class="info-value" id="participantCount">0</span>
                </div>
            </div>
            <div class="join-url" id="joinUrl">
                Students can join at: https://join.intellaclick.com/session/XXXXX
            </div>
            <div class="qr-container">
                <div class="qr-code" id="qrcode"></div>
                <div class="qr-info">
                    <h3>Scan to Join</h3>
                    <p>Students can scan this QR code with their phone to join the session instantly. The code contains the direct link to join this session.</p>
                </div>
            </div>
        </div>

        <div class="section" id="questionSection">
            <h2>Question Management</h2>
            
            <!-- Question Queue -->
            <div id="questionQueue" style="margin-bottom: 20px;">
                <h3 style="font-size: 16px; margin-bottom: 12px;">Question Queue</h3>
                <div id="queueList" style="background-color: var(--background); padding: 12px; border-radius: 8px; min-height: 60px;">
                    <p style="color: var(--text-secondary); font-size: 14px;">No questions in queue. Create a new question or import from a quiz.</p>
                </div>
            </div>

            <!-- Current Question Display -->
            <div id="currentQuestionSection" style="display: none; margin-bottom: 20px;">
                <h3 style="font-size: 16px; margin-bottom: 12px;">Current Question</h3>
                <div style="background-color: #EFF6FF; padding: 16px; border-radius: 8px;">
                    <h4 id="questionText" style="margin-bottom: 12px;"></h4>
                    <div id="questionOptions"></div>
                </div>
            </div>

            <div class="control-buttons">
                <button class="btn btn-primary" onclick="openDisplayView()" style="font-size: 1rem; font-weight: 600;">
                    <svg width="20" height="20" fill="currentColor" style="margin-right: 6px;">
                        <path d="M0 1.5A1.5 1.5 0 0 1 1.5 0h13A1.5 1.5 0 0 1 16 1.5v13a1.5 1.5 0 0 1-1.5 1.5h-13A1.5 1.5 0 0 1 0 14.5v-13zM1.5 1a.5.5 0 0 0-.5.5v13a.5.5 0 0 0 .5.5h13a.5.5 0 0 0 .5-.5v-13a.5.5 0 0 0-.5-.5h-13z"/>
                        <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
                    </svg>
                    üñ•Ô∏è Open Display View
                </button>
                <button class="btn btn-primary" onclick="showQuestionModal()">
                    <svg width="16" height="16" fill="currentColor" style="margin-right: 4px;">
                        <path d="M8 2a.5.5 0 0 1 .5.5v5h5a.5.5 0 0 1 0 1h-5v5a.5.5 0 0 1-1 0v-5h-5a.5.5 0 0 1 0-1h5v-5A.5.5 0 0 1 8 2Z"/>
                    </svg>
                    Create Question
                </button>
                <button class="btn btn-secondary" onclick="showImportModal()">
                    <svg width="16" height="16" fill="currentColor" style="margin-right: 4px;">
                        <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/>
                        <path d="M7.646 1.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 2.707V11.5a.5.5 0 0 1-1 0V2.707L5.354 4.854a.5.5 0 1 1-.708-.708l3-3z"/>
                    </svg>
                    Import Quiz
                </button>
                <button class="btn btn-secondary" onclick="showBulkEditModal()" style="background-color: #6366F1; color: white;">
                    <svg width="16" height="16" fill="currentColor" style="margin-right: 4px;">
                        <path d="M12.146.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1 0 .708l-10 10a.5.5 0 0 1-.168.11l-5 2a.5.5 0 0 1-.65-.65l2-5a.5.5 0 0 1 .11-.168l10-10zM11.207 2.5 13.5 4.793 14.793 3.5 12.5 1.207 11.207 2.5zm1.586 3L10.5 3.207 4 9.707V10h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.293l6.5-6.5zm-9.761 5.175-.106.106-1.528 3.821 3.821-1.528.106-.106A.5.5 0 0 1 5 12.5V12h-.5a.5.5 0 0 1-.5-.5V11h-.5a.5.5 0 0 1-.468-.325z"/>
                    </svg>
                    Bulk Edit
                </button>
                <button class="btn btn-success" onclick="sendNextQuestion()" disabled id="sendBtn">Next Question</button>
                <button class="btn btn-secondary" onclick="stopQuestion()" disabled id="stopBtn">Stop Question</button>
                <button class="btn btn-success" onclick="showResults()" disabled id="resultsBtn">Show Results</button>
            </div>
        </div>

        <div class="section">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                <h2 style="margin: 0;">Participants</h2>
                <button class="btn btn-secondary" onclick="loadSession()" style="padding: 6px 12px; font-size: 12px;">
                    Refresh
                </button>
            </div>
            <div id="participantsList" class="participants-grid">
                <p style="color: var(--text-secondary);">No participants yet. Share the session code for students to join.</p>
            </div>
        </div>

        <div class="section" id="responsesSection" style="display: none;">
            <h2>Responses</h2>
            <div class="response-chart" id="responseChart">
                Response data will appear here
            </div>
        </div>

        <div class="control-buttons">
            <button class="btn btn-danger" onclick="endSession()">End Session</button>
            <a href="../pages/classes.html" class="btn btn-secondary">Back to Classes</a>
        </div>
    </div>


    <!-- Create Question Modal -->
    <div id="questionModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="close" onclick="closeQuestionModal()">&times;</span>
                <h2>Create Quick Question</h2>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="modalQuestionText">Question</label>
                    <textarea id="modalQuestionText" rows="3" placeholder="Enter your question here..."></textarea>
                </div>
                
                <div class="form-group">
                    <label for="modalQuestionType">Question Type</label>
                    <select id="modalQuestionType" onchange="updateModalOptions()">
                        <option value="mcq">Multiple Choice</option>
                        <option value="tf">True/False</option>
                        <option value="matching">Matching</option>
                        <option value="ordering">Put in Order</option>
                        <option value="fillblank">Fill in the Blank</option>
                    </select>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px;">
                    <div class="form-group" style="margin-bottom: 0;">
                        <label for="modalTimeLimit">Time Limit (seconds)</label>
                        <input type="number" id="modalTimeLimit" value="60" min="10" max="300">
                    </div>
                    <div class="form-group" style="margin-bottom: 0;">
                        <label for="modalPoints">Points</label>
                        <input type="number" id="modalPoints" value="10" min="1" max="100">
                    </div>
                </div>

                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; user-select: none;">
                        <input type="checkbox" id="modalAwardParticipation" style="width: 20px; height: 20px; cursor: pointer;">
                        <span>Award points for participation (even if answer is wrong)</span>
                    </label>
                </div>

                <div id="modalQuestionOptions">
                    <!-- Options will be dynamically inserted based on question type -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeQuestionModal()">Cancel</button>
                <button class="btn btn-primary" onclick="addQuestionToQueue()">Add to Queue</button>
            </div>
        </div>
    </div>

    <!-- Import Quiz Modal -->
    <div id="importModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="close" onclick="closeImportModal()">&times;</span>
                <h2>Import Quiz Questions</h2>
            </div>
            <div class="modal-body">
                <p style="margin-bottom: 16px;">Select a quiz to import its questions:</p>
                <div class="quiz-list" id="quizList">
                    <p style="color: var(--text-secondary); text-align: center; padding: 20px;">Loading quizzes...</p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeImportModal()">Cancel</button>
                <button class="btn btn-primary" onclick="importSelectedQuiz()" disabled id="importBtn">Import Selected</button>
            </div>
        </div>
    </div>

    <!-- Bulk Edit Modal -->
    <div id="bulkEditModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="close" onclick="closeBulkEditModal()">&times;</span>
                <h2>Apply Settings to All Questions</h2>
            </div>
            <div class="modal-body">
                <p style="margin-bottom: 16px; color: var(--text-secondary);">
                    Select which settings to apply to all <span id="bulkEditCount" style="font-weight: 600; color: var(--text-primary);">0</span> questions in the queue:
                </p>

                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; user-select: none; margin-bottom: 12px;">
                        <input type="checkbox" id="bulkEditTimeLimit" style="width: 20px; height: 20px; cursor: pointer;">
                        <span style="font-weight: 500;">Change Time Limit</span>
                    </label>
                    <input type="number" id="bulkTimeLimit" value="60" min="10" max="300" disabled style="margin-left: 28px; width: calc(100% - 28px);" placeholder="Time limit in seconds">
                </div>

                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; user-select: none; margin-bottom: 12px;">
                        <input type="checkbox" id="bulkEditPoints" style="width: 20px; height: 20px; cursor: pointer;">
                        <span style="font-weight: 500;">Change Points Value</span>
                    </label>
                    <input type="number" id="bulkPoints" value="10" min="1" max="100" disabled style="margin-left: 28px; width: calc(100% - 28px);" placeholder="Points per question">
                </div>

                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; user-select: none;">
                        <input type="checkbox" id="bulkEditParticipation" style="width: 20px; height: 20px; cursor: pointer;">
                        <span style="font-weight: 500;">Award Participation Points</span>
                    </label>
                    <p style="font-size: 13px; color: var(--text-secondary); margin-left: 28px; margin-top: 4px;">
                        When checked, students will receive points even if their answer is wrong
                    </p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeBulkEditModal()">Cancel</button>
                <button class="btn btn-primary" onclick="applyBulkEdit()">Apply to All Questions</button>
            </div>
        </div>
    </div>

    <script type="module">
        // === Modular Imports ===
        import { sessions, gamifiedSessions } from '../utils/api.js';
        import toast from '../utils/toast.js';
        import logger from '../utils/logger.js';
        import loading from '../utils/loading.js';
        import confirm from '../utils/confirm.js';

        let sessionId;
        let sessionCode;
        let sessionData;
        let classId;
        let questionQueue = [];
        let currentQuestionIndex = -1;
        let pollInterval;
        let selectedQuizId = null;
        let questionDefaults = {
            defaultTimeLimit: 60,
            defaultPoints: 10,
            defaultAwardParticipation: false
        };

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            const urlParams = new URLSearchParams(window.location.search);
            sessionId = urlParams.get('id');
            sessionCode = urlParams.get('code');
            const sessionType = urlParams.get('type');
            
            if (!sessionId || !sessionCode) {
                toast.error('Invalid session parameters');
                setTimeout(() => window.location.href = '../pages/classes.html', 2000);
                return;
            }

            // Check for pending question from create-session page
            // Load multiple questions from sessionStorage (new format)
            const questionsData = sessionStorage.getItem('pendingQuestions');
            if (questionsData) {
                const questions = JSON.parse(questionsData);
                questionQueue.push(...questions); // Add all questions to queue
                sessionStorage.removeItem('pendingQuestions');
                sessionStorage.removeItem('currentQuestionIndex');
                updateQueueDisplay();
            } else {
                // Fallback to single question format (legacy support)
                const questionData = sessionStorage.getItem('pendingQuestion');
                if (questionData) {
                    const question = JSON.parse(questionData);
                    questionQueue.push(question);
                    sessionStorage.removeItem('pendingQuestion');
                    updateQueueDisplay();
                }
            }

            // NEW: Try to restore queue from sessionStorage first (for same browser session)
            if (questionQueue.length === 0) {
                const savedQueue = sessionStorage.getItem('questionQueue_' + sessionCode);
                const savedIndex = sessionStorage.getItem('questionIndex_' + sessionCode);

                if (savedQueue) {
                    console.log('[Session] Restoring queue from sessionStorage');
                    questionQueue = JSON.parse(savedQueue);
                    currentQuestionIndex = savedIndex ? parseInt(savedIndex) : -1;
                    updateQueueDisplay();
                }
            }

            // NEW: If still empty, try to restore from backend (for crashed/resumed sessions)
            if (questionQueue.length === 0) {
                console.log('[Session] Attempting to restore queue from backend');
                restoreQueueFromBackend();
            }

            checkAuth();
            loadSession();
            loadQuestionDefaults(); // Load question defaults from backend
            startPolling();
        });

        function checkAuth() {
            const token = localStorage.getItem('token');
            if (!token) {
                window.location.href = '/login.html';
            }
        }

        async function loadSession() {
            try {
                const response = await fetch(`https://api-modular.intellaclick.com/api/sessions/code/${sessionCode}`, {
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    }
                });

                if (!response.ok) throw new Error('Failed to load session');

                const data = await response.json();
                sessionData = data.session;
                classId = sessionData.classId; // Get classId from session data
                
                logger.debug('Session loaded:', {
                    sessionId: sessionId,
                    sessionCode: sessionCode,
                    sessionData: sessionData,
                    hasCurrentQuestion: !!sessionData.currentQuestion
                });
                
                updateSessionDisplay();
            } catch (error) {
                logger.error('Error loading session:', error);
                toast.error('Failed to load session');
            }
        }

        // Load question defaults from backend
        async function loadQuestionDefaults() {
            try {
                const response = await fetch('https://api-modular.intellaclick.com/api/users/question-defaults', {
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    }
                });

                if (response.ok) {
                    const data = await response.json();
                    questionDefaults = data.defaults || questionDefaults;

                    // Pre-fill modal inputs with defaults
                    document.getElementById('modalTimeLimit').value = questionDefaults.defaultTimeLimit;
                    document.getElementById('modalPoints').value = questionDefaults.defaultPoints;
                    document.getElementById('modalAwardParticipation').checked = questionDefaults.defaultAwardParticipation;

                    logger.debug('‚úÖ Loaded question defaults:', questionDefaults);
                } else {
                    logger.debug('No saved question defaults found, using system defaults');
                }
            } catch (error) {
                logger.error('Error loading question defaults:', error);
            }
        }

        // NEW: Restore question queue from backend (for crashed/resumed sessions)
        async function restoreQueueFromBackend() {
            try {
                const response = await fetch(`https://api-modular.intellaclick.com/api/sessions/${sessionId}`, {
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    }
                });

                if (!response.ok) {
                    console.error('[Session] Failed to fetch session data for queue restoration');
                    return;
                }

                const data = await response.json();

                if (data.success && data.session.questionQueue && data.session.questionQueue.length > 0) {
                    questionQueue = data.session.questionQueue;
                    currentQuestionIndex = data.session.currentQuestionIndex ?? -1;

                    console.log('[Session] Queue restored from backend:', {
                        queueLength: questionQueue.length,
                        currentIndex: currentQuestionIndex
                    });

                    updateQueueDisplay();
                    toast.success(`Restored ${questionQueue.length} questions from previous session`);
                } else {
                    console.log('[Session] No saved queue found in backend');
                }
            } catch (error) {
                console.error('[Session] Error restoring queue from backend:', error);
            }
        }

        // NEW: Save question queue to backend (for crash recovery)
        async function saveQueueToBackend() {
            try {
                const response = await fetch(`https://api-modular.intellaclick.com/api/sessions/${sessionId}/question-queue`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    },
                    body: JSON.stringify({
                        questionQueue: questionQueue,
                        currentQuestionIndex: currentQuestionIndex
                    })
                });

                if (!response.ok) {
                    console.error('[Session] Failed to save queue to backend');
                    return;
                }

                console.log('[Session] Queue saved to backend successfully');
            } catch (error) {
                console.error('[Session] Error saving queue to backend:', error);
                // Don't show error to user - this is a background operation
            }
        }

        function updateSessionDisplay() {
            document.getElementById('sessionCode').textContent = sessionData.sessionCode;
            document.getElementById('participantCount').textContent = sessionData.participantCount || 0;
            
            const joinUrl = `https://join.intellaclick.com/session/${sessionData.sessionCode}`;
            document.getElementById('joinUrl').innerHTML = `
                <strong>Students can join at:</strong><br>
                <div style="display: flex; align-items: center; gap: 12px; margin: 8px 0;">
                    <span style="font-size: 16px; user-select: all; flex: 1;">${joinUrl}</span>
                    <button class="btn btn-secondary" onclick="copyJoinUrl('${joinUrl}')" style="padding: 6px 12px; font-size: 12px;">
                        Copy Link
                    </button>
                </div>
                <small style="color: var(--text-secondary); margin-top: 4px; display: block;">
                    Session ID: ${sessionData.id || sessionData._id}<br>
                    ${sessionData.restrictToEnrolled === false ? 'Open to all students' : 'Restricted to enrolled students only'}
                </small>
            `;
            
            // Generate QR code
            generateQRCode(joinUrl);
            
            // Update status badge
            const statusEl = document.getElementById('sessionStatus');
            statusEl.textContent = sessionData.status.charAt(0).toUpperCase() + sessionData.status.slice(1);
            statusEl.className = `status-badge status-${sessionData.status}`;
            
            // Update button states
            if (sessionData.status === 'active' && sessionData.currentQuestion) {
                document.getElementById('stopBtn').disabled = false;
                document.getElementById('resultsBtn').disabled = false;
                displayCurrentQuestion(sessionData.currentQuestion);
            }
            
            // Update participants list
            updateParticipantsList();
        }
        
        function updateParticipantsList() {
            const participantsList = document.getElementById('participantsList');
            
            // Load detailed participant info if available
            fetch(`https://api-modular.intellaclick.com/api/sessions/${sessionId}/participants`, {
                headers: {
                    'Authorization': `Bearer ${localStorage.getItem('token')}`
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.participants && data.participants.length > 0) {
                    participantsList.innerHTML = '';
                    data.participants.forEach(p => {
                        const card = document.createElement('div');
                        card.className = 'participant-card';
                        card.innerHTML = `
                            <strong>${p.name || 'Anonymous'}</strong><br>
                            <small style="color: var(--text-secondary);">
                                Joined: ${new Date(p.joinedAt).toLocaleTimeString()}<br>
                                ${p.isEnrolled ? 'Enrolled Student' : 'Guest'}
                            </small>
                        `;
                        participantsList.appendChild(card);
                    });
                } else {
                    participantsList.innerHTML = '<p style="color: var(--text-secondary);">No participants yet. Share the session code for students to join.</p>';
                }
            })
            .catch(error => {
                logger.error('Error loading participants:', error);
            });
        }

        function generateQRCode(url) {
            const qrContainer = document.getElementById('qrcode');
            qrContainer.innerHTML = ''; // Clear existing QR code
            
            // Create a canvas element
            const canvas = document.createElement('canvas');
            
            QRCode.toCanvas(canvas, url, {
                width: 400,
                margin: 2,
                color: {
                    dark: '#000000',
                    light: '#FFFFFF'
                }
            }, function(error) {
                if (error) {
                    logger.error('QR Code generation error:', error);
                    qrContainer.innerHTML = '<p style="color: var(--text-secondary);">QR Code generation failed</p>';
                    return;
                }
                
                canvas.style.width = '200px';
                canvas.style.height = '200px';
                qrContainer.appendChild(canvas);
            });
        }

        // Question Queue Management
        function updateQueueDisplay() {
            const queueList = document.getElementById('queueList');

            // Save queue to sessionStorage for display view (immediate access)
            sessionStorage.setItem('questionQueue_' + sessionCode, JSON.stringify(questionQueue));
            sessionStorage.setItem('questionIndex_' + sessionCode, currentQuestionIndex.toString());

            // NEW: Save to backend (for crash recovery)
            saveQueueToBackend();

            if (questionQueue.length === 0) {
                queueList.innerHTML = '<p style="color: var(--text-secondary); font-size: 14px;">No questions in queue. Create a new question or import from a quiz.</p>';
                document.getElementById('sendBtn').disabled = true;
            } else {
                queueList.innerHTML = '';
                questionQueue.forEach((question, index) => {
                    const item = document.createElement('div');
                    item.className = 'question-item';
                    
                    const text = document.createElement('div');
                    text.className = 'question-item-text';
                    text.innerHTML = `<strong>${index + 1}.</strong> ${question.text || question.questionText}`;
                    
                    const actions = document.createElement('div');
                    actions.className = 'question-item-actions';
                    
                    if (index > currentQuestionIndex) {
                        const editBtn = document.createElement('button');
                        editBtn.className = 'btn btn-secondary';
                        editBtn.style.padding = '4px 8px';
                        editBtn.style.fontSize = '12px';
                        editBtn.style.marginRight = '4px';
                        editBtn.textContent = 'Edit';
                        editBtn.onclick = () => editQueueQuestion(index);
                        actions.appendChild(editBtn);

                        const removeBtn = document.createElement('button');
                        removeBtn.className = 'btn btn-secondary';
                        removeBtn.style.padding = '4px 8px';
                        removeBtn.style.fontSize = '12px';
                        removeBtn.textContent = 'Remove';
                        removeBtn.onclick = () => removeFromQueue(index);
                        actions.appendChild(removeBtn);
                    }
                    
                    item.appendChild(text);
                    item.appendChild(actions);
                    queueList.appendChild(item);
                });
                
                document.getElementById('sendBtn').disabled = false;
            }
        }

        function removeFromQueue(index) {
            questionQueue.splice(index, 1);
            updateQueueDisplay();
        }

        let editingQuestionIndex = null;

        function editQueueQuestion(index) {
            editingQuestionIndex = index;
            const question = questionQueue[index];

            // Open the question modal
            document.getElementById('questionModal').style.display = 'block';

            // Set question type and text
            const questionType = question.type || question.questionType || 'mcq';
            logger.debug('Editing question with type:', questionType);
            document.getElementById('modalQuestionType').value = questionType;
            document.getElementById('modalQuestionText').value = question.text || question.questionText || '';

            // Update options display after type is set
            setTimeout(() => updateModalOptions(), 10);

            // Pre-fill data based on question type
            setTimeout(() => {
                switch(question.type) {
                    case 'mcq':
                        if (question.optionTexts) {
                            ['A', 'B', 'C', 'D'].forEach((letter, idx) => {
                                const input = document.getElementById(`modalOption${letter}`);
                                if (input && question.optionTexts[idx]) {
                                    input.value = question.optionTexts[idx];
                                }
                                if (question.correctAnswer === letter || question.correctAnswer === idx) {
                                    const radio = document.querySelector(`input[name="modalCorrect"][value="${letter}"]`);
                                    if (radio) radio.checked = true;
                                }
                            });
                        }
                        break;

                    case 'tf':
                        const tfValue = question.correctAnswer === 'true' || question.correctAnswer === true ? 'true' : 'false';
                        const tfRadio = document.querySelector(`input[name="modalTF"][value="${tfValue}"]`);
                        if (tfRadio) tfRadio.checked = true;
                        break;

                    case 'matching':
                        if (question.pairs) {
                            question.pairs.forEach((pair, idx) => {
                                const leftInput = document.getElementById(`modalMatch${idx + 1}Left`);
                                const rightInput = document.getElementById(`modalMatch${idx + 1}Right`);
                                if (leftInput) leftInput.value = pair.left || '';
                                if (rightInput) rightInput.value = pair.right || '';
                            });
                        }
                        break;

                    case 'ordering':
                        if (question.correctOrder) {
                            question.correctOrder.forEach((item, idx) => {
                                const input = document.getElementById(`modalOrder${idx + 1}`);
                                if (input) input.value = item || '';
                            });
                        }
                        break;

                    case 'fillblank':
                        const answerInput = document.getElementById('modalBlankAnswer');
                        if (answerInput) answerInput.value = question.correctAnswer || '';
                        break;
                }
            }, 100);

            // Change modal title
            const modalTitle = document.querySelector('#questionModal h2');
            if (modalTitle) modalTitle.textContent = 'Edit Question';
        }

        async function sendNextQuestion() {
            if (currentQuestionIndex + 1 >= questionQueue.length) {
                toast.error('No more questions in queue');
                return;
            }

            currentQuestionIndex++;

            // Save updated index to sessionStorage
            sessionStorage.setItem('questionIndex_' + sessionCode, currentQuestionIndex.toString());

            const question = questionQueue[currentQuestionIndex];

            // Normalize question type for student interface compatibility
            const normalizedQuestion = {...question};

            // Remove the original 'type' field to avoid confusion
            delete normalizedQuestion.type;

            // Map our types to what the student interface expects
            const typeMap = {
                'mcq': 'multiple_choice',
                'tf': 'boolean',  // Try 'boolean' instead of 'true_false'
                'matching': 'matching',
                'ordering': 'ordering',
                'fillblank': 'fill_blank'
            };

            // Set both questionType and type to the mapped value
            const mappedType = typeMap[question.type] || question.type;
            normalizedQuestion.questionType = mappedType;
            normalizedQuestion.type = mappedType;

            // Ensure questionText is set
            normalizedQuestion.questionText = question.text || question.questionText;

            // Handle type-specific data
            if (question.type === 'tf') {
                // For true/false, ensure options are properly formatted
                normalizedQuestion.options = ['True', 'False'];
            } else if (question.type === 'mcq') {
                // Ensure MCQ has options and optionTexts
                if (question.optionTexts) {
                    normalizedQuestion.options = question.options;
                    normalizedQuestion.optionTexts = question.optionTexts;
                }
            } else if (question.type === 'matching') {
                // Ensure matching has pairs
                normalizedQuestion.pairs = question.pairs || [];
                // Shuffle the right column items ONCE here, so both instructor and student see same order
                const rightItems = normalizedQuestion.pairs.map(p => p.right);
                const shuffledRight = rightItems.sort(() => Math.random() - 0.5);
                normalizedQuestion.shuffledMatchingRight = shuffledRight;
            } else if (question.type === 'ordering') {
                // Ensure ordering has correctOrder
                normalizedQuestion.correctOrder = question.correctOrder || [];
                // Shuffle the items ONCE here, so both instructor and student see same order
                const shuffledItems = [...normalizedQuestion.correctOrder].sort(() => Math.random() - 0.5);
                normalizedQuestion.shuffledOrderingItems = shuffledItems;
            } else if (question.type === 'fillblank') {
                // Ensure fill-in-blank has correctAnswer
                normalizedQuestion.correctAnswer = question.correctAnswer || '';
            }
            
            // Debug logging
            logger.debug('Sending question:', {
                sessionId: sessionId,
                endpoint: `https://api-modular.intellaclick.com/api/sessions/${sessionId}/questions`,
                questionData: normalizedQuestion,
                hasQuestionText: !!normalizedQuestion.questionText,
                questionType: normalizedQuestion.questionType
            });

            try {
                const response = await fetch(`https://api-modular.intellaclick.com/api/sessions/${sessionId}/questions`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    },
                    body: JSON.stringify(normalizedQuestion)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    logger.error('API Error:', {
                        status: response.status,
                        error: errorData
                    });
                    throw new Error(errorData.error || 'Failed to send question');
                }

                const result = await response.json();
                logger.debug('Question sent successfully:', result);

                toast.success('Question sent successfully!');
                document.getElementById('stopBtn').disabled = false;
                document.getElementById('resultsBtn').disabled = false;

                // Display current question immediately
                displayCurrentQuestion(question);

                // Update queue display
                updateQueueDisplay();

                // Wait a bit for server to save, then reload session
                setTimeout(async () => {
                    await loadSession();
                }, 500);
            } catch (error) {
                logger.error('Error sending question:', error);
                
                // Check if it's a CORS error
                if (error.name === 'TypeError' && error.message === 'Failed to fetch') {
                    toast.error('Network error: Unable to reach the API server. This may be a CORS issue.');
                    logger.error('CORS Error Details:', {
                        error: error,
                        message: 'The API server may need to add instructor.intellaclick.com to its allowed origins',
                        currentOrigin: window.location.origin,
                        apiUrl: 'https://api-modular.intellaclick.com'
                    });
                    
                    // Show more detailed error in alert for debugging
                    if (confirm('Network error detected. This is likely a CORS configuration issue.\n\nThe backend needs to add instructor.intellaclick.com to its allowed origins.\n\nClick OK to open the CORS test page for more details.')) {
                        window.open('/cors-test.html', '_blank');
                    }
                } else {
                    toast.error(error.message || 'Failed to send question');
                }
                
                currentQuestionIndex--; // Revert on error
            }
        }

        function displayCurrentQuestion(question) {
            document.getElementById('currentQuestionSection').style.display = 'block';

            // Normalize question format (handle both local queue format and server format)
            const questionType = question.type || question.questionType;
            const questionText = question.text || question.questionText || '';

            // DEBUG: Log question data
            logger.debug('üì∫ DISPLAYING QUESTION IN SESSION CONTROL:', {
                questionType,
                questionText,
                hasPairs: !!question.pairs,
                pairs: question.pairs,
                hasCorrectOrder: !!question.correctOrder,
                correctOrder: question.correctOrder,
                fullQuestion: question
            });

            // Display question text with blanks rendered as visual blanks
            let questionTextHtml = questionText;
            if (questionType === 'fillblank' || questionType === 'fill_blank') {
                // Replace [blank] with a styled visual blank
                questionTextHtml = questionTextHtml.replace(/\[blank\]/gi, '<span style="display: inline-block; min-width: 100px; border-bottom: 2px solid #4F46E5; margin: 0 6px; height: 1.2em; vertical-align: bottom;"></span>');
            }
            document.getElementById('questionText').innerHTML = questionTextHtml;

            // Display options based on question type
            const optionsDiv = document.getElementById('questionOptions');
            optionsDiv.innerHTML = '';

            if ((questionType === 'mcq' || questionType === 'multiple_choice') && (question.optionTexts || question.options)) {
                const optionTexts = question.optionTexts || question.options;
                const optionLetters = question.options && question.optionTexts ? question.options : ['A', 'B', 'C', 'D'];
                optionLetters.forEach((option, index) => {
                    if (optionTexts[index]) {
                        const optionEl = document.createElement('div');
                        optionEl.style.marginTop = '8px';
                        optionEl.textContent = `${option}: ${optionTexts[index]}`;
                        optionsDiv.appendChild(optionEl);
                    }
                });
            } else if (questionType === 'tf' || questionType === 'boolean') {
                optionsDiv.innerHTML = '<div style="margin-top: 8px;">A: True</div><div style="margin-top: 8px;">B: False</div>';
            } else if (questionType === 'matching' && question.pairs) {
                optionsDiv.innerHTML = '<strong>Match the following:</strong>';
                // Display left column (stays in order)
                question.pairs.forEach((pair, index) => {
                    const pairEl = document.createElement('div');
                    pairEl.style.marginTop = '8px';
                    pairEl.textContent = `${index + 1}. ${pair.left} ‚Üí ?`;
                    optionsDiv.appendChild(pairEl);
                });
                // Display shuffled right column that students will see
                if (question.shuffledMatchingRight) {
                    const rightDiv = document.createElement('div');
                    rightDiv.style.marginTop = '12px';
                    rightDiv.innerHTML = '<strong>Options to match:</strong>';
                    question.shuffledMatchingRight.forEach((item, index) => {
                        const optEl = document.createElement('div');
                        optEl.style.marginTop = '4px';
                        optEl.textContent = `${String.fromCharCode(65 + index)}. ${item}`;
                        rightDiv.appendChild(optEl);
                    });
                    optionsDiv.appendChild(rightDiv);
                }
            } else if ((questionType === 'ordering' || questionType === 'ordering') && question.correctOrder) {
                optionsDiv.innerHTML = '<strong>Put in correct order:</strong>';
                // Use shuffled order if available (same order students see)
                const itemsToDisplay = question.shuffledOrderingItems || question.correctOrder;
                itemsToDisplay.forEach((item, index) => {
                    const itemEl = document.createElement('div');
                    itemEl.style.marginTop = '8px';
                    itemEl.textContent = `${String.fromCharCode(65 + index)}. ${item}`;
                    optionsDiv.appendChild(itemEl);
                });
            }
        }

        // Modal Functions
        function showQuestionModal() {
            document.getElementById('questionModal').style.display = 'block';
            updateModalOptions(); // Initialize with default options
        }

        function closeQuestionModal() {
            document.getElementById('questionModal').style.display = 'none';
            // Clear form
            document.getElementById('modalQuestionText').value = '';
            document.getElementById('modalQuestionType').value = 'mcq';
            // Reset editing mode
            editingQuestionIndex = null;
            // Reset modal title
            const modalTitle = document.querySelector('#questionModal h2');
            if (modalTitle) modalTitle.textContent = 'Create Question';
        }

        function showImportModal() {
            document.getElementById('importModal').style.display = 'block';
            loadQuizzes();
        }

        function closeImportModal() {
            document.getElementById('importModal').style.display = 'none';
            selectedQuizId = null;
        }

        function updateModalOptions() {
            const type = document.getElementById('modalQuestionType').value;
            const optionsDiv = document.getElementById('modalQuestionOptions');
            
            switch(type) {
                case 'mcq':
                    optionsDiv.innerHTML = `
                        <label>Answer Options (select correct answer)</label>
                        <div style="margin-top: 8px;">
                            <input type="radio" name="modalCorrect" value="A" checked> 
                            <input type="text" id="modalOptionA" placeholder="Option A" style="width: calc(100% - 30px); margin-left: 8px;">
                        </div>
                        <div style="margin-top: 8px;">
                            <input type="radio" name="modalCorrect" value="B"> 
                            <input type="text" id="modalOptionB" placeholder="Option B" style="width: calc(100% - 30px); margin-left: 8px;">
                        </div>
                        <div style="margin-top: 8px;">
                            <input type="radio" name="modalCorrect" value="C"> 
                            <input type="text" id="modalOptionC" placeholder="Option C" style="width: calc(100% - 30px); margin-left: 8px;">
                        </div>
                        <div style="margin-top: 8px;">
                            <input type="radio" name="modalCorrect" value="D"> 
                            <input type="text" id="modalOptionD" placeholder="Option D" style="width: calc(100% - 30px); margin-left: 8px;">
                        </div>
                    `;
                    break;
                    
                case 'tf':
                    optionsDiv.innerHTML = `
                        <label>Correct Answer</label>
                        <div style="margin-top: 8px;">
                            <input type="radio" name="modalTF" value="true" checked> True
                            <input type="radio" name="modalTF" value="false" style="margin-left: 20px;"> False
                        </div>
                    `;
                    break;
                    
                case 'matching':
                    optionsDiv.innerHTML = `
                        <label>Matching Pairs</label>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 8px;">
                            <input type="text" placeholder="Item 1" id="modalMatch1Left">
                            <input type="text" placeholder="Match 1" id="modalMatch1Right">
                            <input type="text" placeholder="Item 2" id="modalMatch2Left">
                            <input type="text" placeholder="Match 2" id="modalMatch2Right">
                            <input type="text" placeholder="Item 3" id="modalMatch3Left">
                            <input type="text" placeholder="Match 3" id="modalMatch3Right">
                        </div>
                    `;
                    break;
                    
                case 'ordering':
                    optionsDiv.innerHTML = `
                        <label>Items in Correct Order</label>
                        <div style="margin-top: 8px;">
                            <input type="text" placeholder="1st item" id="modalOrder1" style="margin-bottom: 8px;">
                            <input type="text" placeholder="2nd item" id="modalOrder2" style="margin-bottom: 8px;">
                            <input type="text" placeholder="3rd item" id="modalOrder3" style="margin-bottom: 8px;">
                            <input type="text" placeholder="4th item" id="modalOrder4">
                        </div>
                    `;
                    break;
                    
                case 'fillblank':
                    optionsDiv.innerHTML = `
                        <label>Correct Answer</label>
                        <input type="text" id="modalBlankAnswer" placeholder="Enter the correct answer" style="margin-top: 8px;">
                        <small style="display: block; margin-top: 8px; color: var(--text-secondary);">Use [blank] in your question where the answer should go</small>
                    `;
                    break;
            }
        }

        async function stopQuestion() {
            try {
                // Get current question ID from session data
                const questionId = sessionData.currentQuestion?.questionId || 'current';
                
                const response = await fetch(`https://api-modular.intellaclick.com/api/sessions/${sessionId}/questions/${questionId}/end`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    }
                });

                if (!response.ok) throw new Error('Failed to stop question');

                toast.success('Question stopped');
                document.getElementById('currentQuestionSection').style.display = 'none';
                await loadSession();
            } catch (error) {
                logger.error('Error stopping question:', error);
                toast.error('Failed to stop question');
            }
        }

        async function showResults() {
            try {
                // Fetch responses from backend
                const response = await fetch(`https://api-modular.intellaclick.com/api/sessions/code/${sessionCode}/responses`);
                const data = await response.json();

                if (!data.success) {
                    toast.error('Failed to load results');
                    return;
                }

                // Also fetch session data to get question details
                const sessionResponse = await fetch(`https://api-modular.intellaclick.com/api/sessions/code/${sessionCode}`);
                const sessionInfo = await sessionResponse.json();

                console.log('üìä Results data:', {
                    responses: data.responses,
                    responsesByQuestion: data.responsesByQuestion,
                    sessionQuestions: sessionInfo.session?.questions,
                    currentQuestion: sessionInfo.session?.currentQuestion
                });

                // Display the responses section
                document.getElementById('responsesSection').style.display = 'block';

                // Render results with full session data
                renderResults(data.responses, data.responsesByQuestion, sessionInfo.session);

                // Scroll to results
                document.getElementById('responsesSection').scrollIntoView({ behavior: 'smooth' });

            } catch (error) {
                console.error('Error fetching results:', error);
                toast.error('Failed to load results');
            }
        }

        function renderResults(responses, responsesByQuestion, fullSessionData) {
            const chartDiv = document.getElementById('responseChart');

            if (!responses || responses.length === 0) {
                chartDiv.innerHTML = '<p style="color: var(--text-secondary); text-align: center; padding: 40px;">No responses yet</p>';
                return;
            }

            let html = `<h3>Session Results Summary</h3>`;
            html += `<p style="margin-bottom: 20px; color: var(--text-secondary);">Total Responses: ${responses.length}</p>`;

            // Create vertical container for question cards
            html += '<div style="padding-bottom: 20px;">';

            // Group by question
            for (const [questionId, questionResponses] of Object.entries(responsesByQuestion)) {
                // Strategy 1: Find in session questions array (try both _id and questionId fields)
                let question = fullSessionData?.questions?.find(q =>
                    q._id?.toString() === questionId ||
                    q.questionId === questionId ||
                    q.id === questionId
                );

                // Strategy 2: Check in questionQueue
                if (!question && fullSessionData?.questionQueue) {
                    question = fullSessionData.questionQueue.find(q =>
                        q._id?.toString() === questionId ||
                        q.questionId === questionId ||
                        q.id === questionId
                    );
                }

                // Strategy 3: Check if it's the current question
                if (!question && fullSessionData?.currentQuestion) {
                    const curr = fullSessionData.currentQuestion;
                    if (curr._id?.toString() === questionId ||
                        curr.questionId === questionId ||
                        curr.id === questionId) {
                        question = curr;
                    }
                }

                // Strategy 4: Look in the response data itself
                if (!question && questionResponses.length > 0) {
                    const sampleResponse = responses.find(r => r.questionId === questionId);
                    if (sampleResponse) {
                        question = sampleResponse.questionData || sampleResponse.question || sampleResponse.questionDetails;
                    }
                }

                // Debug logging to understand what we're finding
                console.log('üîç Question lookup:', {
                    questionId,
                    questionsArray: fullSessionData?.questions,
                    questionQueue: fullSessionData?.questionQueue,
                    foundQuestion: question,
                    firstResponse: questionResponses[0],
                    fullResponse: responses.find(r => r.questionId === questionId)
                });

                const questionText = question?.text || question?.questionText || 'Question text not found';
                const questionType = question?.type || question?.questionType || 'unknown';
                const options = question?.options || [];
                let correctAnswer = question?.correctAnswer;

                // Convert letter answer (A, B, C, D) to numeric index (0, 1, 2, 3)
                if (typeof correctAnswer === 'string' && correctAnswer.length === 1 && correctAnswer >= 'A' && correctAnswer <= 'Z') {
                    correctAnswer = correctAnswer.charCodeAt(0) - 'A'.charCodeAt(0);
                }
                // Convert boolean string answer to index
                else if (questionType === 'boolean' && typeof correctAnswer === 'string') {
                    if (correctAnswer === 'true' || correctAnswer === 'True') correctAnswer = 0;
                    else if (correctAnswer === 'false' || correctAnswer === 'False') correctAnswer = 1;
                }

                html += `
                    <div style="background: white; border-radius: 8px; padding: 20px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                        <h4 style="margin-bottom: 16px; word-wrap: break-word;">${questionText}</h4>
                        <p style="color: var(--text-secondary); font-size: 13px; margin-bottom: 12px;">
                            ${questionResponses.length} response${questionResponses.length !== 1 ? 's' : ''}
                        </p>
                `;

                // Count answers for visualization
                const answerCounts = {};
                questionResponses.forEach(r => {
                    let answer = r.answer;

                    // Convert letter answers (A, B, C, D) to numeric indices (0, 1, 2, 3)
                    if (typeof answer === 'string' && answer.length === 1 && answer >= 'A' && answer <= 'Z') {
                        answer = answer.charCodeAt(0) - 'A'.charCodeAt(0);
                    }
                    // Convert boolean string answers to indices
                    else if (questionType === 'boolean') {
                        if (answer === 'true' || answer === true) answer = 0;
                        else if (answer === 'false' || answer === false) answer = 1;
                    }
                    // For matching, ordering, fill_blank - keep as-is for now (displayed in table only)

                    answerCounts[answer] = (answerCounts[answer] || 0) + 1;
                });

                // Debug: Show what we're counting
                console.log('üìä Answer counting:', {
                    questionId,
                    questionResponses,
                    answerCounts,
                    options,
                    questionType
                });

                // Show answer distribution for multiple choice, polls, and boolean
                if (questionType === 'multiple_choice' || questionType === 'mcq' || questionType === 'poll' || questionType === 'boolean') {
                    html += '<div style="margin-bottom: 20px;">';
                    options.forEach((option, index) => {
                        const count = answerCounts[index] || 0;
                        const percentage = Math.round((count / questionResponses.length) * 100) || 0;
                        const isCorrect = correctAnswer === index;
                        const showCorrectMark = (questionType === 'multiple_choice' || questionType === 'mcq') && isCorrect;

                        html += `
                            <div style="margin-bottom: 12px;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                                    <span style="font-weight: 500;">
                                        ${option} ${showCorrectMark ? '<span style="color: var(--secondary-color);">‚úì Correct</span>' : ''}
                                    </span>
                                    <span style="color: var(--text-secondary);">${count} (${percentage}%)</span>
                                </div>
                                <div style="background: #E5E7EB; height: 8px; border-radius: 4px; overflow: hidden;">
                                    <div style="background: ${showCorrectMark ? 'var(--secondary-color)' : 'var(--primary-color)'}; height: 100%; width: ${percentage}%; transition: width 0.3s;"></div>
                                </div>
                            </div>
                        `;
                    });
                    html += '</div>';
                }

                // Show correct answer for all question types
                if (questionType === 'multiple_choice' || questionType === 'mcq') {
                    console.log('üîç MCQ correct answer check:', {
                        questionType,
                        correctAnswer,
                        options,
                        hasCorrectAnswer: correctAnswer !== undefined,
                        optionAtIndex: options[correctAnswer]
                    });
                    if (correctAnswer !== undefined && options[correctAnswer]) {
                        html += '<div style="background: #F0FDF4; border-left: 4px solid var(--secondary-color); padding: 12px; margin-bottom: 16px; border-radius: 4px;">';
                        html += '<strong style="color: var(--secondary-color);">Correct Answer:</strong> ';
                        html += `<span>${options[correctAnswer]}</span>`;
                        html += '</div>';
                    }
                } else if (questionType === 'boolean') {
                    console.log('üîç Boolean correct answer check:', {
                        questionType,
                        correctAnswer,
                        options,
                        hasCorrectAnswer: correctAnswer !== undefined,
                        optionAtIndex: options[correctAnswer]
                    });
                    if (correctAnswer !== undefined && options[correctAnswer]) {
                        html += '<div style="background: #F0FDF4; border-left: 4px solid var(--secondary-color); padding: 12px; margin-bottom: 16px; border-radius: 4px;">';
                        html += '<strong style="color: var(--secondary-color);">Correct Answer:</strong> ';
                        html += `<span>${options[correctAnswer]}</span>`;
                        html += '</div>';
                    }
                } else if (questionType === 'matching') {
                    console.log('üîç Matching question debug:', {
                        question,
                        pairs: question?.pairs,
                        leftColumn: question?.leftColumn,
                        rightColumn: question?.rightColumn,
                        correctPairs: question?.correctPairs,
                        correctAnswer: question?.correctAnswer
                    });

                    // Build leftColumn from pairs array if not available
                    let leftColumn = question?.leftColumn || [];
                    if (leftColumn.length === 0 && question?.pairs && Array.isArray(question.pairs)) {
                        leftColumn = question.pairs.map(pair => pair.left);
                        console.log('üìù Built leftColumn from pairs:', leftColumn);
                    }

                    const correctPairs = question?.correctPairs || question?.correctAnswer;
                    if (correctPairs) {
                        html += '<div style="background: #F0FDF4; border-left: 4px solid var(--secondary-color); padding: 12px; margin-bottom: 16px; border-radius: 4px;">';
                        html += '<strong style="color: var(--secondary-color);">Correct Answer:</strong><br>';
                        const correctPairsText = Object.entries(correctPairs)
                            .map(([index, right]) => {
                                const leftItem = leftColumn[parseInt(index)] || index;
                                return `${leftItem} ‚Üí ${right}`;
                            })
                            .join(', ');
                        html += `<span style="margin-top: 4px; display: block;">${correctPairsText}</span>`;
                        html += '</div>';
                    }
                } else if (questionType === 'ordering' && question?.correctOrder) {
                    html += '<div style="background: #F0FDF4; border-left: 4px solid var(--secondary-color); padding: 12px; margin-bottom: 16px; border-radius: 4px;">';
                    html += '<strong style="color: var(--secondary-color);">Correct Order:</strong><br>';
                    html += `<span style="margin-top: 4px; display: block;">${question.correctOrder.join(', ')}</span>`;
                    html += '</div>';
                } else if (questionType === 'fill_blank' && question?.correctAnswer) {
                    html += '<div style="background: #F0FDF4; border-left: 4px solid var(--secondary-color); padding: 12px; margin-bottom: 16px; border-radius: 4px;">';
                    html += '<strong style="color: var(--secondary-color);">Correct Answer:</strong><br>';
                    html += `<span style="margin-top: 4px; display: block;">${question.correctAnswer}</span>`;
                    html += '</div>';
                }

                // Show student responses
                html += '<details style="margin-top: 16px;">';
                html += '<summary style="cursor: pointer; color: var(--primary-color); font-weight: 500;">View individual responses</summary>';
                html += '<div style="margin-top: 12px; max-height: 300px; overflow-y: auto;">';
                html += '<table style="width: 100%; border-collapse: collapse;">';
                html += '<tr style="background: #F9FAFB;"><th style="text-align: left; padding: 8px;">Student</th><th style="text-align: left; padding: 8px;">Answer</th><th style="text-align: left; padding: 8px;">Time</th></tr>';

                questionResponses.forEach(r => {
                    let answerText;

                    if (questionType === 'multiple_choice' || questionType === 'mcq' || questionType === 'poll') {
                        // Convert letter answer to index
                        let answerIndex = r.answer;
                        if (typeof answerIndex === 'string' && answerIndex.length === 1 && answerIndex >= 'A' && answerIndex <= 'Z') {
                            answerIndex = answerIndex.charCodeAt(0) - 'A'.charCodeAt(0);
                        }
                        answerText = options[answerIndex] || r.answer;
                    } else if (questionType === 'boolean') {
                        // Display boolean as True/False
                        answerText = r.answer === 'true' || r.answer === true ? 'True' : 'False';
                    } else if (questionType === 'matching') {
                        // Display matching pairs - map indices to actual left column items
                        if (typeof r.answer === 'object' && r.answer !== null) {
                            // Build leftColumn from pairs array if not available
                            let leftColumn = question?.leftColumn || [];
                            if (leftColumn.length === 0 && question?.pairs && Array.isArray(question.pairs)) {
                                leftColumn = question.pairs.map(pair => pair.left);
                            }

                            console.log('üîç Processing matching answer:', {
                                answer: r.answer,
                                leftColumn,
                                participantName: r.participantName
                            });
                            answerText = Object.entries(r.answer)
                                .map(([index, right]) => {
                                    const leftItem = leftColumn[parseInt(index)] || index;
                                    console.log(`   Mapping: index=${index}, right=${right}, leftItem=${leftItem}`);
                                    return `${leftItem} ‚Üí ${right}`;
                                })
                                .join(', ');
                        } else {
                            answerText = JSON.stringify(r.answer);
                        }
                    } else if (questionType === 'ordering') {
                        // Display ordered list
                        if (Array.isArray(r.answer)) {
                            answerText = r.answer.join(', ');
                        } else {
                            answerText = r.answer;
                        }
                    } else if (questionType === 'fill_blank') {
                        // Display as plain text
                        answerText = r.answer;
                    } else {
                        answerText = r.answer;
                    }

                    const time = r.submittedAt ? new Date(r.submittedAt).toLocaleTimeString() : 'N/A';

                    html += `
                        <tr style="border-bottom: 1px solid #E5E7EB;">
                            <td style="padding: 8px;">${r.participantName}</td>
                            <td style="padding: 8px;">${answerText}</td>
                            <td style="padding: 8px; color: var(--text-secondary);">${time}</td>
                        </tr>
                    `;
                });

                html += '</table></div></details>';
                html += '</div>'; // Close question card
            }

            html += '</div>'; // Close horizontal container

            chartDiv.innerHTML = html;
        }

        async function endSession() {
            if (!confirm('Are you sure you want to end this session?')) return;

            try {
                // Check if gamification is enabled for this session
                const hasGamification = sessionData?.gamificationEnabled && sessionData?.classId;

                let response;
                if (hasGamification) {
                    logger.debug('Ending session with gamification processing...');
                    // Use gamification endpoint which processes points, levels, achievements
                    response = await fetch(`https://api-modular.intellaclick.com/api/sessions-gamified/${sessionId}/end-with-gamification`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${localStorage.getItem('token')}`
                        }
                    });
                } else {
                    logger.debug('Ending session (no gamification)...');
                    // Use regular endpoint
                    response = await fetch(`https://api-modular.intellaclick.com/api/sessions/${sessionId}/status`, {
                        method: 'PATCH',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${localStorage.getItem('token')}`
                        },
                        body: JSON.stringify({ status: 'ended' })
                    });
                }

                if (!response.ok) throw new Error('Failed to end session');

                const result = await response.json();
                logger.debug('Session ended:', result);

                if (hasGamification && result.gamificationResults) {
                    toast.success(`Session ended - ${result.gamificationResults.length} students earned points!`);
                } else {
                    toast.success('Session ended');
                }

                stopPolling();
                setTimeout(() => window.location.href = '../pages/classes.html', 2000);
            } catch (error) {
                logger.error('Error ending session:', error);
                toast.error('Failed to end session');
            }
        }

        function startPolling() {
            // Poll for updates every 3 seconds
            pollInterval = setInterval(loadSession, 3000);
        }

        function stopPolling() {
            if (pollInterval) {
                clearInterval(pollInterval);
            }
        }

        function openDisplayView() {
            const displayUrl = `../pages/display.html?id=${sessionId}&code=${sessionCode}`;
            window.open(displayUrl, 'IntellaClickDisplay', 'width=1920,height=1080,menubar=no,toolbar=no,location=no,status=no');
        }


        function copyJoinUrl(url) {
            navigator.clipboard.writeText(url).then(() => {
                toast.success('Link copied to clipboard!');
            }).catch(err => {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = url;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    toast.success('Link copied to clipboard!');
                } catch (err) {
                    toast.error('Failed to copy link');
                }
                document.body.removeChild(textArea);
            });
        }

        function copySessionCode() {
            const code = document.getElementById('sessionCode').textContent;
            navigator.clipboard.writeText(code).then(() => {
                toast.success('Session code copied!');
            }).catch(err => {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = code;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    toast.success('Session code copied!');
                } catch (err) {
                    toast.error('Failed to copy code');
                }
                document.body.removeChild(textArea);
            });
        }

        // Add Question to Queue
        function addQuestionToQueue() {
            const questionText = document.getElementById('modalQuestionText').value.trim();
            const questionType = document.getElementById('modalQuestionType').value;

            if (!questionText) {
                toast.error('Please enter a question');
                return;
            }

            // Read values from modal inputs
            const timeLimit = parseInt(document.getElementById('modalTimeLimit').value) || 60;
            const points = parseInt(document.getElementById('modalPoints').value) || 10;
            const awardParticipation = document.getElementById('modalAwardParticipation').checked;

            let question = {
                text: questionText,
                type: questionType,
                timeLimit: timeLimit,  // ‚úÖ Read from input
                points: points,        // ‚úÖ Read from input
                awardParticipationPoints: awardParticipation  // ‚úÖ Read from checkbox
            };
            
            // Build question based on type
            switch(questionType) {
                case 'mcq':
                    const options = [];
                    const optionTexts = [];
                    let correctAnswer = null;
                    
                    ['A', 'B', 'C', 'D'].forEach(letter => {
                        const optionInput = document.getElementById(`modalOption${letter}`);
                        if (optionInput && optionInput.value.trim()) {
                            options.push(letter);
                            optionTexts.push(optionInput.value.trim());
                            
                            const radio = document.querySelector(`input[name="modalCorrect"][value="${letter}"]`);
                            if (radio && radio.checked) {
                                correctAnswer = letter;
                            }
                        }
                    });
                    
                    if (options.length < 2) {
                        toast.error('Please provide at least 2 options');
                        return;
                    }
                    
                    question.options = options;
                    question.optionTexts = optionTexts;
                    question.correctAnswer = correctAnswer;
                    break;
                    
                case 'tf':
                    question.options = ['True', 'False'];
                    question.correctAnswer = document.querySelector('input[name="modalTF"]:checked').value;
                    break;
                    
                case 'matching':
                    const pairs = [];
                    for (let i = 1; i <= 3; i++) {
                        const left = document.getElementById(`modalMatch${i}Left`).value.trim();
                        const right = document.getElementById(`modalMatch${i}Right`).value.trim();
                        if (left && right) {
                            pairs.push({ left, right });
                        }
                    }
                    
                    if (pairs.length < 2) {
                        toast.error('Please provide at least 2 matching pairs');
                        return;
                    }
                    
                    question.pairs = pairs;
                    break;
                    
                case 'ordering':
                    const items = [];
                    for (let i = 1; i <= 4; i++) {
                        const item = document.getElementById(`modalOrder${i}`).value.trim();
                        if (item) {
                            items.push(item);
                        }
                    }
                    
                    if (items.length < 2) {
                        toast.error('Please provide at least 2 items');
                        return;
                    }
                    
                    question.correctOrder = items;
                    break;
                    
                case 'fillblank':
                    const answer = document.getElementById('modalBlankAnswer').value.trim();
                    if (!answer) {
                        toast.error('Please provide the correct answer');
                        return;
                    }
                    
                    if (!questionText.includes('[blank]')) {
                        toast.error('Please include [blank] in your question');
                        return;
                    }
                    
                    question.correctAnswer = answer;
                    break;
            }
            
            // Add to queue or update existing
            if (editingQuestionIndex !== null) {
                // Update existing question
                questionQueue[editingQuestionIndex] = question;
                editingQuestionIndex = null;
                toast.success('Question updated');
            } else {
                // Add new question
                questionQueue.push(question);
                toast.success('Question added to queue');
            }

            updateQueueDisplay();
            closeQuestionModal();
        }

        // Load and Import Quizzes
        async function loadQuizzes() {
            try {
                const response = await fetch(`https://api-modular.intellaclick.com/api/quizzes`, {
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    }
                });

                if (!response.ok) throw new Error('Failed to load quizzes');

                const data = await response.json();
                const quizzes = data.quizzes || [];

                const quizList = document.getElementById('quizList');
                if (quizzes.length === 0) {
                    quizList.innerHTML = '<p style="color: var(--text-secondary); text-align: center; padding: 20px;">No quizzes found. <a href="../pages/saved-questions.html" style="color: var(--primary-color);">Create your first quiz</a></p>';
                    document.getElementById('importBtn').disabled = true;
                } else {
                    quizList.innerHTML = '';
                    quizzes.forEach(quiz => {
                        const item = document.createElement('div');
                        item.className = 'quiz-item';
                        item.innerHTML = `
                            <strong>${quiz.title}</strong><br>
                            <small style="color: var(--text-secondary);">${quiz.questionCount || 0} questions ‚Ä¢ ${quiz.totalPoints || 0} points</small>
                        `;
                        item.onclick = () => selectQuiz(quiz._id, item);
                        quizList.appendChild(item);
                    });
                }
            } catch (error) {
                logger.error('Error loading quizzes:', error);
                const quizList = document.getElementById('quizList');
                quizList.innerHTML = '<p style="color: var(--danger-color); text-align: center; padding: 20px;">Failed to load quizzes. Please try again.</p>';
            }
        }

        function selectQuiz(quizId, element) {
            selectedQuizId = quizId;
            
            // Update UI
            document.querySelectorAll('.quiz-item').forEach(item => {
                item.classList.remove('selected');
            });
            element.classList.add('selected');
            
            document.getElementById('importBtn').disabled = false;
        }

        async function importSelectedQuiz() {
            if (!selectedQuizId) {
                toast.error('Please select a quiz');
                return;
            }

            try {
                const response = await fetch(`https://api-modular.intellaclick.com/api/quizzes/${selectedQuizId}`, {
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    }
                });

                if (!response.ok) throw new Error('Failed to load quiz');

                const data = await response.json();
                const quiz = data.quiz || data;

                if (quiz.questions && quiz.questions.length > 0) {
                    logger.debug('üìã Applying question defaults to imported quiz:', questionDefaults);

                    // Add all quiz questions to the queue
                    quiz.questions.forEach(q => {
                        // Get question data from snapshot if available
                        const snapshot = q.questionSnapshot || q;

                        // Check both questionType (new schema) and type (old data) for backwards compatibility
                        const questionType = snapshot.questionType || snapshot.type || 'mcq';

                        const question = {
                            text: snapshot.questionText || q.text || '',
                            type: questionType,
                            options: snapshot.options || [],
                            correctAnswer: snapshot.correctAnswer || 0,
                            timeLimit: snapshot.timeLimit || q.timeLimit || questionDefaults.defaultTimeLimit, // ‚úÖ Use default
                            points: snapshot.points || q.points || questionDefaults.defaultPoints, // ‚úÖ Use default
                            awardParticipationPoints: questionDefaults.defaultAwardParticipation // ‚úÖ Apply default
                        };

                        // Add matching question data
                        if (question.type === 'matching' && snapshot.pairs) {
                            question.pairs = snapshot.pairs;
                            logger.debug('üì¶ Imported matching question with pairs:', snapshot.pairs);
                        }

                        // Add ordering question data
                        if (question.type === 'ordering' && snapshot.correctOrder) {
                            question.correctOrder = snapshot.correctOrder;
                            logger.debug('üì¶ Imported ordering question with correctOrder:', snapshot.correctOrder);
                        }

                        questionQueue.push(question);
                    });

                    updateQueueDisplay();
                    closeImportModal();
                    toast.success(`Imported ${quiz.questions.length} questions from ${quiz.title}`);
                } else {
                    toast.error('Quiz has no questions');
                }
            } catch (error) {
                logger.error('Error importing quiz:', error);
                toast.error('Failed to import quiz');
            }
        }

        // Close modals when clicking outside
        window.onclick = function(event) {
            if (event.target.className === 'modal') {
                event.target.style.display = 'none';
            }
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', stopPolling);

        // === Bulk Edit Functions ===

        function showBulkEditModal() {
            if (questionQueue.length === 0) {
                toast.error('No questions in queue to edit');
                return;
            }

            // Update question count in modal
            document.getElementById('bulkEditCount').textContent = questionQueue.length;

            // Enable/disable inputs based on checkboxes
            document.getElementById('bulkEditTimeLimit').addEventListener('change', function() {
                document.getElementById('bulkTimeLimit').disabled = !this.checked;
            });

            document.getElementById('bulkEditPoints').addEventListener('change', function() {
                document.getElementById('bulkPoints').disabled = !this.checked;
            });

            // Show modal
            document.getElementById('bulkEditModal').style.display = 'block';
        }

        function closeBulkEditModal() {
            document.getElementById('bulkEditModal').style.display = 'none';
        }

        function applyBulkEdit() {
            const changeTimeLimit = document.getElementById('bulkEditTimeLimit').checked;
            const changePoints = document.getElementById('bulkEditPoints').checked;
            const changeParticipation = document.getElementById('bulkEditParticipation').checked;

            if (!changeTimeLimit && !changePoints && !changeParticipation) {
                toast.error('Please select at least one setting to apply');
                return;
            }

            const newTimeLimit = parseInt(document.getElementById('bulkTimeLimit').value);
            const newPoints = parseInt(document.getElementById('bulkPoints').value);
            const newParticipation = changeParticipation;

            let updatedCount = 0;

            questionQueue.forEach(question => {
                if (changeTimeLimit) {
                    question.timeLimit = newTimeLimit;
                }
                if (changePoints) {
                    question.points = newPoints;
                }
                if (changeParticipation) {
                    question.awardParticipationPoints = newParticipation;
                }
                updatedCount++;
            });

            // Save updated queue to backend
            saveQueueToBackend();

            // Update display
            updateQueueDisplay();

            // Close modal
            closeBulkEditModal();

            // Show success message
            toast.success(`Updated ${updatedCount} questions successfully!`);

            logger.debug('‚úÖ Bulk edit applied:', {
                changeTimeLimit,
                changePoints,
                changeParticipation,
                updatedCount
            });
        }

        // Expose functions to window for onclick handlers
        window.copySessionCode = copySessionCode;
        window.openDisplayView = openDisplayView;
        window.showQuestionModal = showQuestionModal;
        window.showImportModal = showImportModal;
        window.sendNextQuestion = sendNextQuestion;
        window.stopQuestion = stopQuestion;
        window.showResults = showResults;
        window.loadSession = loadSession;
        window.endSession = endSession;
        window.closeQuestionModal = closeQuestionModal;
        window.addQuestionToQueue = addQuestionToQueue;
        window.closeImportModal = closeImportModal;
        window.importSelectedQuiz = importSelectedQuiz;
        window.copyJoinUrl = copyJoinUrl;
        window.updateModalOptions = updateModalOptions;
        window.showBulkEditModal = showBulkEditModal;
        window.closeBulkEditModal = closeBulkEditModal;
        window.applyBulkEdit = applyBulkEdit;
    </script>
</body>
</html>