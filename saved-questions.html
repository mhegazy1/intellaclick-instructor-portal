<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="version" content="1.0.9-smaller-headers">
    <title>Saved Question Sets - IntellaClick</title>
    <link rel="stylesheet" href="styles/common.css">
    <link rel="stylesheet" href="styles/saved-questions.css">
</head>
<body>
    <div class="container">
        <!-- Version Check: 1.0.8-three-columns - If you see this in page source, file is loading -->
        <a href="classes.html" class="back-link">← Back to Classes</a>
        <div class="header">
            <h1>Saved Question Sets</h1>
            <div class="bulk-actions">
                <button class="btn btn-secondary btn-small" onclick="toggleSelectAll()">
                    <span id="selectAllText">Select All</span>
                </button>
                <button class="btn btn-danger btn-small" onclick="deleteSelected()" id="deleteSelectedBtn" disabled>
                    Delete Selected (<span id="selectedCount">0</span>)
                </button>
                <button class="btn btn-primary btn-small" onclick="showCreateQuestionSetModal()">
                    ➕ Create New Question Set
                </button>
            </div>
        </div>

        <div class="stats-bar">
            <div class="stat-item">
                <div class="stat-value" id="totalSets">0</div>
                <div class="stat-label">Question Sets</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="totalQuestions">0</div>
                <div class="stat-label">Total Questions</div>
            </div>
        </div>

        <div class="search-section">
            <input type="text" id="searchInput" placeholder="Search question sets..." oninput="filterQuestionSets()">
        </div>

        <div id="questionSetsContainer" class="question-sets-grid">
            <!-- Question sets will be loaded here -->
        </div>

        <div id="emptyState" class="empty-state" style="display: none;">
            <svg width="64" height="64" fill="currentColor">
                <path d="M6 9a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2V9Zm2-1a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1H8Z"/>
            </svg>
            <p style="font-size: 1.125rem; margin-bottom: 0.5rem;">No saved question sets yet</p>
            <p>Create a new question set or use questions from sessions</p>
        </div>
    </div>

    <!-- Create Question Set Modal -->
    <div id="createModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 10000; padding: 2rem; overflow-y: auto;">
        <div style="background: white; max-width: 800px; margin: 0 auto; border-radius: 12px; padding: 2rem;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; border-bottom: 1px solid #e5e7eb; padding-bottom: 1rem;">
                <h2 style="font-size: 1.5rem; font-weight: 700;">Create New Question Set</h2>
                <button onclick="closeCreateModal()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #6b7280;">&times;</button>
            </div>

            <!-- Question Set Name -->
            <div style="margin-bottom: 1.5rem;">
                <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Question Set Name *</label>
                <input type="text" id="newSetName" placeholder="e.g., Week 5 Review Questions" style="width: 100%; padding: 0.75rem; border: 1px solid #e5e7eb; border-radius: 8px; font-size: 1rem;">
            </div>

            <!-- Questions List -->
            <div style="margin-bottom: 1.5rem;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <label style="font-weight: 600;">Questions</label>
                    <button class="btn btn-secondary" onclick="addNewQuestion()" style="font-size: 0.875rem; padding: 0.5rem 1rem;">
                        ➕ Add Question
                    </button>
                </div>
                <div id="newQuestionsList"></div>
                <div id="emptyQuestions" style="text-align: center; padding: 2rem; color: #6b7280; background: #f9fafb; border-radius: 8px;">
                    <p>No questions added yet. Click "Add Question" to get started.</p>
                </div>
            </div>

            <!-- Action Buttons -->
            <div style="display: flex; gap: 12px; justify-content: flex-end;">
                <button class="btn btn-secondary" onclick="closeCreateModal()">Cancel</button>
                <button class="btn btn-primary" onclick="editingSetId ? updateQuestionSet() : saveNewQuestionSet()">
                    <span id="saveButtonText">Save Question Set</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Question Builder Modal -->
    <div id="questionBuilderModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.6); z-index: 10001; padding: 2rem; overflow-y: auto;">
        <div style="background: white; max-width: 700px; margin: 0 auto; border-radius: 12px; padding: 2rem;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
                <h3 style="font-size: 1.25rem; font-weight: 700;">Add Question</h3>
                <button onclick="closeQuestionBuilder()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer;">&times;</button>
            </div>

            <form id="questionBuilderForm" onsubmit="saveQuestion(event)">
                <!-- Question Type -->
                <div style="margin-bottom: 1rem;">
                    <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Question Type *</label>
                    <select id="builderQuestionType" onchange="updateQuestionBuilderUI()" style="width: 100%; padding: 0.75rem; border: 1px solid #e5e7eb; border-radius: 8px;">
                        <option value="mcq">Multiple Choice</option>
                        <option value="tf">True/False</option>
                        <option value="fillblank">Fill in the Blank</option>
                    </select>
                </div>

                <!-- Question Text -->
                <div style="margin-bottom: 1rem;">
                    <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Question Text *</label>
                    <textarea id="builderQuestionText" rows="3" placeholder="Enter your question here..." required style="width: 100%; padding: 0.75rem; border: 1px solid #e5e7eb; border-radius: 8px; font-size: 1rem;"></textarea>
                </div>

                <!-- MCQ Options -->
                <div id="mcqOptions" style="margin-bottom: 1rem;">
                    <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Answer Options *</label>
                    <div id="optionsList"></div>
                    <button type="button" class="btn btn-secondary" onclick="addOption()" style="margin-top: 0.5rem; font-size: 0.875rem;">+ Add Option</button>
                </div>

                <!-- TF Options -->
                <div id="tfOptions" style="margin-bottom: 1rem; display: none;">
                    <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Correct Answer *</label>
                    <select id="builderTFAnswer" style="width: 100%; padding: 0.75rem; border: 1px solid #e5e7eb; border-radius: 8px;">
                        <option value="true">True</option>
                        <option value="false">False</option>
                    </select>
                </div>

                <!-- Fill-in-Blank Options -->
                <div id="fillBlankOptions" style="margin-bottom: 1rem; display: none;">
                    <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Correct Answer(s) *</label>
                    <p style="color: #6b7280; font-size: 0.875rem; margin-bottom: 0.5rem;">Use [blank] in the question text to indicate where the blank should go. Enter acceptable answers below (one per line, case-insensitive).</p>
                    <textarea id="builderFillBlankAnswers" rows="3" placeholder="Enter acceptable answers, one per line&#10;Example:&#10;photosynthesis&#10;Photosynthesis" style="width: 100%; padding: 0.75rem; border: 1px solid #e5e7eb; border-radius: 8px; font-size: 1rem;"></textarea>
                </div>

                <!-- Action Buttons -->
                <div style="display: flex; gap: 12px; justify-content: flex-end; margin-top: 1.5rem;">
                    <button type="button" class="btn btn-secondary" onclick="closeQuestionBuilder()">Cancel</button>
                    <button type="submit" class="btn btn-primary">Add Question</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Question Selector Modal -->
    <div id="questionSelectorModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 10000; padding: 2rem; overflow-y: auto;">
        <div style="background: white; max-width: 800px; margin: 0 auto; border-radius: 12px; padding: 2rem;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; border-bottom: 1px solid #e5e7eb; padding-bottom: 1rem;">
                <h2 style="font-size: 1.5rem; font-weight: 700;">Select Questions to Use</h2>
                <button onclick="closeSelectorModal()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #6b7280;">&times;</button>
            </div>

            <div style="margin-bottom: 1rem; display: flex; gap: 12px;">
                <button class="btn btn-secondary" onclick="selectAllQuestions()">Select All</button>
                <button class="btn btn-secondary" onclick="deselectAllQuestions()">Deselect All</button>
            </div>

            <div id="questionCheckboxList" style="max-height: 400px; overflow-y: auto; margin-bottom: 1.5rem;">
                <!-- Checkboxes will be populated here -->
            </div>

            <div style="display: flex; gap: 12px; justify-content: flex-end;">
                <button class="btn btn-secondary" onclick="closeSelectorModal()">Cancel</button>
                <button class="btn btn-primary" onclick="loadSelectedQuestions()">Use Selected Questions</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { questionSets } from './utils/api.js';
        import logger from './utils/logger.js';
        import loading from './utils/loading.js';

        let allQuestionSets = [];
        let selectedSets = new Set();

        logger.debug('🔵 Saved Questions Page Loaded - Version 1.0.2-button-fix');

        document.addEventListener('DOMContentLoaded', () => {
            logger.debug('🔵 DOMContentLoaded - initializing page');
            loadQuestionSets();
        });

        async function loadQuestionSets() {
            loading.show('Loading question sets...');
            try {
                const token = localStorage.getItem('token');
                if (!token) {
                    throw new Error('Not authenticated. Please log in.');
                }

                logger.debug('Loading question sets from cloud API...');
                logger.debug('Token present:', !!token);

                const data = await questionSets.getAll();
                allQuestionSets = data.questionSets || [];

                logger.debug(`✅ Loaded ${allQuestionSets.length} question sets from cloud`);

                // Update stats
                document.getElementById('totalSets').textContent = allQuestionSets.length;
                const totalQ = allQuestionSets.reduce((sum, set) => sum + (set.questionCount || set.questions?.length || 0), 0);
                document.getElementById('totalQuestions').textContent = totalQ;

                renderQuestionSets(allQuestionSets);
            } catch (error) {
                logger.error('Error loading question sets:', error);
                logger.error('Error details:', error.message);
                alert(`Failed to load question sets: ${error.message}\n\nThe backend may need to be restarted on Coolify.`);

                // Show empty state
                document.getElementById('totalSets').textContent = '0';
                document.getElementById('totalQuestions').textContent = '0';
                renderQuestionSets([]);
            } finally {
                loading.hide();
            }
        }

        function renderQuestionSets(sets) {
            const container = document.getElementById('questionSetsContainer');
            const emptyState = document.getElementById('emptyState');

            if (sets.length === 0) {
                container.style.display = 'none';
                emptyState.style.display = 'block';
                return;
            }

            container.style.display = 'grid';
            emptyState.style.display = 'none';

            container.innerHTML = sets.map((set, index) => {
                const date = new Date(set.createdAt).toLocaleDateString();
                const time = new Date(set.createdAt).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

                // Show first 3 questions as preview
                const preview = set.questions.slice(0, 3).map(q => {
                    const typeLabel = getTypeLabel(q.type);
                    const questionText = q.text || q.questionText || 'Question';
                    return `<div class="question-preview-item">
                        <span class="question-type-badge">${typeLabel}</span>
                        ${questionText.substring(0, 60)}${questionText.length > 60 ? '...' : ''}
                    </div>`;
                }).join('');

                const setId = set._id || set.id;
                const isSelected = selectedSets.has(setId);

                return `
                    <div class="question-set-card">
                        <div class="question-set-header-with-checkbox">
                            <input type="checkbox" class="set-checkbox"
                                   data-set-id="${setId}"
                                   ${isSelected ? 'checked' : ''}
                                   onclick="toggleSetSelection('${setId}')">
                            <div class="question-set-header-content">
                                <div class="question-set-header">
                                    <div>
                                        <div class="question-set-title">${set.name}</div>
                                        <div class="question-set-meta">${date} at ${time}</div>
                                    </div>
                                    <span class="question-count-badge">${set.questionCount} Q's</span>
                                </div>
                            </div>
                        </div>

                        <div class="question-preview">
                            ${preview}
                            ${set.questions.length > 3 ? `<div style="text-align: center; padding: 0.5rem; color: var(--text-secondary); font-size: 0.875rem;">+ ${set.questions.length - 3} more questions</div>` : ''}
                        </div>

                        <div class="question-set-actions">
                            <button class="btn btn-primary" onclick="event.stopPropagation(); showQuestionSelector('${setId}')">
                                Use Questions
                            </button>
                            <button class="btn btn-secondary" onclick="event.stopPropagation(); editQuestionSet('${setId}')">
                                Edit
                            </button>
                            <button class="btn btn-secondary" onclick="event.stopPropagation(); viewQuestionSet('${setId}')">
                                View All
                            </button>
                            <button class="btn btn-danger" onclick="event.stopPropagation(); deleteQuestionSet('${setId}')">
                                Delete
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
            updateSelectionUI();
        }

        function getTypeLabel(type) {
            const labels = {
                'mcq': 'Multiple Choice',
                'tf': 'True/False',
                'matching': 'Matching',
                'ordering': 'Put in Order',
                'fillblank': 'Fill Blank'
            };
            return labels[type] || type;
        }

        function filterQuestionSets() {
            const search = document.getElementById('searchInput').value.toLowerCase();

            if (!search) {
                renderQuestionSets(allQuestionSets);
                return;
            }

            const filtered = allQuestionSets.filter(set =>
                set.name.toLowerCase().includes(search) ||
                set.questions.some(q =>
                    (q.text || q.questionText || '').toLowerCase().includes(search)
                )
            );

            renderQuestionSets(filtered);
        }

        function loadQuestionSet(setId) {
            logger.debug('=== loadQuestionSet CALLED ===');
            logger.debug('setId:', setId);
            logger.debug('allQuestionSets:', allQuestionSets);

            const set = allQuestionSets.find(s => {
                const id = s._id || s.id;
                logger.debug('Comparing:', id, '===', setId, '?', id === setId);
                return id === setId;
            });

            logger.debug('Found set:', set);

            if (!set) {
                alert('Question set not found. Check console for details.');
                return;
            }

            // Ensure all questions have timeLimit and points (for backward compatibility)
            const questionsWithDefaults = set.questions.map(q => ({
                ...q,
                timeLimit: q.timeLimit || 60,
                points: q.points || 10
            }));

            // Store in sessionStorage
            sessionStorage.setItem('pendingQuestions', JSON.stringify(questionsWithDefaults));
            sessionStorage.setItem('fromSavedSet', 'true');

            logger.debug('✅ Questions saved to sessionStorage');

            // Get the classId from URL or sessionStorage to navigate back
            const urlParams = new URLSearchParams(window.location.search);
            const returnUrl = urlParams.get('returnUrl') || sessionStorage.getItem('createSessionUrl');

            if (returnUrl) {
                // Automatically navigate back to create-session page
                logger.debug('Navigating back to:', returnUrl);
                window.location.href = returnUrl;
            } else {
                // Fallback: show alert if we don't know where to return
                alert(`✅ Loaded "${set.name}" with ${set.questionCount} questions!\n\nGo back to the session page to use them.`);
            }
        }

        function viewQuestionSet(setId) {
            logger.debug('Viewing question set:', setId);
            const set = allQuestionSets.find(s => (s._id || s.id) === setId);

            if (!set) {
                alert('Question set not found');
                return;
            }

            let details = `<div style="max-width: 600px; text-align: left;">
                <h3>${set.name}</h3>
                <p><strong>Created:</strong> ${new Date(set.createdAt).toLocaleString()}</p>
                <p><strong>Questions:</strong> ${set.questionCount}</p>
                <hr style="margin: 1rem 0;">`;

            set.questions.forEach((q, i) => {
                const typeLabel = getTypeLabel(q.type);
                details += `<div style="margin-bottom: 1rem; padding: 1rem; background: #f8f9fa; border-radius: 8px;">
                    <strong>${i + 1}. [${typeLabel}]</strong><br>
                    ${q.text || q.questionText}
                </div>`;
            });

            details += '</div>';

            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 10000; padding: 2rem;';
            modal.innerHTML = `<div style="background: white; padding: 2rem; border-radius: 12px; max-height: 80vh; overflow-y: auto; max-width: 800px;">${details}<button class="btn btn-primary" onclick="this.closest('div[style*=fixed]').remove()" style="margin-top: 1rem; width: 100%;">Close</button></div>`;
            document.body.appendChild(modal);

            modal.addEventListener('click', (e) => {
                if (e.target === modal) modal.remove();
            });
        }

        async function deleteQuestionSet(setId) {
            logger.debug('Deleting question set:', setId);
            const set = allQuestionSets.find(s => (s._id || s.id) === setId);

            if (!set) {
                alert('Question set not found');
                return;
            }

            const confirmed = await confirm(`Delete "${set.name}"?\n\nThis cannot be undone.`);
            if (!confirmed) return;

            loading.show('Deleting question set...');
            try {
                await questionSets.delete(setId);

                logger.debug('✅ Question set deleted successfully');
                alert('Question set deleted successfully');

                // Reload the list
                loadQuestionSets();
            } catch (error) {
                logger.error('Error deleting question set:', error);
                alert(`Failed to delete question set: ${error.message}`);
            } finally {
                loading.hide();
            }
        }

        function checkAuth() {
            const token = localStorage.getItem('token');
            if (!token) {
                window.location.href = 'login.html';
            }
        }

        // ========== CREATE QUESTION SET FUNCTIONS ==========

        let newSetQuestions = [];
        let currentEditingIndex = null;

        function showCreateQuestionSetModal() {
            newSetQuestions = [];
            currentEditingIndex = null;
            editingSetId = null;
            document.getElementById('newSetName').value = '';
            document.getElementById('newQuestionsList').innerHTML = '';
            document.getElementById('emptyQuestions').style.display = 'block';
            document.getElementById('saveButtonText').textContent = 'Save Question Set';
            document.getElementById('createModal').style.display = 'flex';
        }

        function closeCreateModal() {
            document.getElementById('createModal').style.display = 'none';
            editingSetId = null;
        }

        function addNewQuestion() {
            // Open question builder modal
            currentEditingIndex = null;
            document.getElementById('builderQuestionText').value = '';
            document.getElementById('builderQuestionType').value = 'mcq';
            document.getElementById('optionsList').innerHTML = '';
            optionCount = 0; // Reset option count
            updateQuestionBuilderUI();
            document.getElementById('questionBuilderModal').style.display = 'flex';
        }

        function closeQuestionBuilder() {
            document.getElementById('questionBuilderModal').style.display = 'none';

            // If we were editing from selector and cancelled, re-show selector
            if (editingSelectorQuestionIndex !== null) {
                editingSelectorQuestionIndex = null;
                document.getElementById('questionSelectorModal').style.display = 'flex';
            }
        }

        function updateQuestionBuilderUI() {
            const type = document.getElementById('builderQuestionType').value;

            // Hide all option sections first
            document.getElementById('mcqOptions').style.display = 'none';
            document.getElementById('tfOptions').style.display = 'none';
            document.getElementById('fillBlankOptions').style.display = 'none';

            // Show the appropriate section based on type
            if (type === 'tf') {
                document.getElementById('tfOptions').style.display = 'block';
            } else if (type === 'fillblank') {
                document.getElementById('fillBlankOptions').style.display = 'block';
            } else {
                // MCQ
                document.getElementById('mcqOptions').style.display = 'block';

                // Initialize with 4 options for MCQ if empty
                const optionsList = document.getElementById('optionsList');
                if (optionsList.children.length === 0) {
                    for (let i = 0; i < 4; i++) {
                        addOption();
                    }
                }
            }
        }

        let optionCount = 0;

        function addOption() {
            const optionsList = document.getElementById('optionsList');
            const index = optionCount++;

            const optionDiv = document.createElement('div');
            optionDiv.style.cssText = 'display: flex; gap: 8px; margin-bottom: 8px; align-items: center;';
            optionDiv.innerHTML = `
                <input type="radio" name="correctAnswer" value="${index}" ${index === 0 ? 'checked' : ''} style="width: 20px; height: 20px;">
                <input type="text" class="option-input" placeholder="Option ${String.fromCharCode(65 + index)}" required style="flex: 1; padding: 0.5rem; border: 1px solid #e5e7eb; border-radius: 6px;">
                <button type="button" onclick="removeOption(this)" style="padding: 0.5rem; background: #ef4444; color: white; border: none; border-radius: 6px; cursor: pointer;">✕</button>
            `;
            optionsList.appendChild(optionDiv);
        }

        function removeOption(btn) {
            const optionsList = document.getElementById('optionsList');
            if (optionsList.children.length > 2) {
                btn.parentElement.remove();
            } else {
                alert('You must have at least 2 options');
            }
        }

        async function saveQuestion(event) {
            event.preventDefault();
            logger.debug('=== saveQuestion called ===');
            logger.debug('currentEditingIndex:', currentEditingIndex);
            logger.debug('editingSelectorQuestionIndex:', editingSelectorQuestionIndex);

            try {
                const type = document.getElementById('builderQuestionType').value;
                const text = document.getElementById('builderQuestionText').value.trim();

                logger.debug('Question type:', type);
                logger.debug('Question text:', text);

                if (!text) {
                    alert('Please enter question text');
                    return;
                }

                const question = {
                    type: type,
                    text: text
                };

                if (type === 'mcq') {
                    const options = Array.from(document.querySelectorAll('.option-input')).map(input => input.value.trim());
                    const correctIndex = parseInt(document.querySelector('input[name="correctAnswer"]:checked').value);

                    logger.debug('MCQ options:', options);
                    logger.debug('Correct index:', correctIndex);

                    if (options.some(opt => !opt)) {
                        alert('Please fill in all options');
                        return;
                    }

                    question.options = options;
                    question.correctAnswer = correctIndex;
                } else if (type === 'tf') {
                    question.correctAnswer = document.getElementById('builderTFAnswer').value;
                    logger.debug('TF correct answer:', question.correctAnswer);
                } else if (type === 'fillblank') {
                    const answersText = document.getElementById('builderFillBlankAnswers').value.trim();

                    if (!answersText) {
                        alert('Please enter at least one acceptable answer');
                        return;
                    }

                    // Split by newlines and filter empty lines
                    const answers = answersText.split('\n')
                        .map(ans => ans.trim())
                        .filter(ans => ans.length > 0);

                    if (answers.length === 0) {
                        alert('Please enter at least one acceptable answer');
                        return;
                    }

                    question.correctAnswer = answers;
                    logger.debug('Fill-blank correct answers:', answers);
                }

                // Check if we're editing from the selector modal
                if (editingSelectorQuestionIndex !== null) {
                    closeQuestionBuilder();
                    await saveSelectorQuestionEdit(question);
                    return;
                }

                // Otherwise, handle normal create/edit flow
                if (currentEditingIndex !== null) {
                    // Update existing question in newSetQuestions
                    newSetQuestions[currentEditingIndex] = question;
                    logger.debug('✅ Question updated at index:', currentEditingIndex);
                } else {
                    // Add new question
                    newSetQuestions.push(question);
                    logger.debug('✅ Question added. Total questions:', newSetQuestions.length);
                }

                renderNewQuestionsList();
                closeQuestionBuilder();

                // Reset for next question
                currentEditingIndex = null;
                optionCount = 0;
                document.getElementById('optionsList').innerHTML = '';
            } catch (error) {
                logger.error('❌ Error saving question:', error);
                alert('Error saving question: ' + error.message);
            }
        }

        function renderNewQuestionsList() {
            const container = document.getElementById('newQuestionsList');
            const emptyState = document.getElementById('emptyQuestions');

            if (newSetQuestions.length === 0) {
                container.innerHTML = '';
                emptyState.style.display = 'block';
                return;
            }

            emptyState.style.display = 'none';
            container.innerHTML = newSetQuestions.map((q, index) => `
                <div style="background: #f9fafb; padding: 1rem; border-radius: 8px; margin-bottom: 0.75rem; display: flex; justify-content: space-between; align-items: start;">
                    <div style="flex: 1;">
                        <div style="font-weight: 600; margin-bottom: 0.25rem;">Q${index + 1}: ${q.text}</div>
                        <div style="font-size: 0.875rem; color: #6b7280;">Type: ${getTypeLabel(q.type)}</div>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button class="btn btn-secondary" onclick="editNewQuestion(${index})" style="padding: 0.5rem 1rem; font-size: 0.875rem;">Edit</button>
                        <button class="btn btn-danger" onclick="removeNewQuestion(${index})" style="padding: 0.5rem 1rem; font-size: 0.875rem;">Remove</button>
                    </div>
                </div>
            `).join('');
        }

        function editNewQuestion(index) {
            const question = newSetQuestions[index];
            currentEditingIndex = index;

            // Populate the question builder with existing data
            document.getElementById('builderQuestionType').value = question.type;
            document.getElementById('builderQuestionText').value = question.text;

            if (question.type === 'mcq') {
                // Clear existing options
                document.getElementById('optionsList').innerHTML = '';
                optionCount = 0;

                // Add options from the question
                question.options.forEach((optionText, idx) => {
                    const optionDiv = document.createElement('div');
                    optionDiv.style.cssText = 'display: flex; gap: 8px; margin-bottom: 8px; align-items: center;';
                    optionDiv.innerHTML = `
                        <input type="radio" name="correctAnswer" value="${idx}" ${idx === question.correctAnswer ? 'checked' : ''} style="width: 20px; height: 20px;">
                        <input type="text" class="option-input" value="${optionText}" placeholder="Option ${String.fromCharCode(65 + idx)}" required style="flex: 1; padding: 0.5rem; border: 1px solid #e5e7eb; border-radius: 6px;">
                        <button type="button" onclick="removeOption(this)" style="padding: 0.5rem; background: #ef4444; color: white; border: none; border-radius: 6px; cursor: pointer;">✕</button>
                    `;
                    document.getElementById('optionsList').appendChild(optionDiv);
                    optionCount++;
                });
            } else if (question.type === 'tf') {
                // True/False
                document.getElementById('builderTFAnswer').value = question.correctAnswer;
            } else if (question.type === 'fillblank') {
                // Fill-in-Blank
                const answers = Array.isArray(question.correctAnswer) ? question.correctAnswer : [question.correctAnswer];
                document.getElementById('builderFillBlankAnswers').value = answers.join('\n');
            }

            updateQuestionBuilderUI();
            document.getElementById('questionBuilderModal').style.display = 'flex';
        }

        function removeNewQuestion(index) {
            newSetQuestions.splice(index, 1);
            renderNewQuestionsList();
        }

        async function saveNewQuestionSet() {
            const name = document.getElementById('newSetName').value.trim();

            if (!name) {
                alert('Please enter a question set name');
                return;
            }

            if (newSetQuestions.length === 0) {
                alert('Please add at least one question');
                return;
            }

            loading.show('Saving question set...');
            try {
                await questionSets.create({
                    name: name,
                    questions: newSetQuestions
                });

                logger.debug('✅ Question set saved successfully');
                alert(`✅ Question set "${name}" created successfully with ${newSetQuestions.length} questions!`);

                closeCreateModal();
                loadQuestionSets(); // Reload the list
            } catch (error) {
                logger.error('Error saving question set:', error);
                alert(`Failed to save question set: ${error.message}`);
            } finally {
                loading.hide();
            }
        }

        // ========== QUESTION SELECTOR FUNCTIONS ==========

        let currentSelectedSetId = null;
        let editingSelectorQuestionIndex = null;

        function showQuestionSelector(setId) {
            logger.debug('Opening question selector for set:', setId);
            const set = allQuestionSets.find(s => (s._id || s.id) === setId);

            if (!set) {
                alert('Question set not found');
                return;
            }

            currentSelectedSetId = setId;

            // Populate checkbox list
            const container = document.getElementById('questionCheckboxList');
            container.innerHTML = set.questions.map((q, index) => {
                const typeLabel = getTypeLabel(q.type);
                const questionText = q.text || q.questionText || 'Question';
                return `
                    <div style="padding: 1rem; background: #f9fafb; border-radius: 8px; margin-bottom: 0.75rem;">
                        <div style="display: flex; align-items: start; gap: 12px;">
                            <input type="checkbox" class="question-checkbox" data-index="${index}" checked style="width: 20px; height: 20px; margin-top: 2px; flex-shrink: 0;">
                            <div style="flex: 1;">
                                <div style="font-weight: 600; margin-bottom: 0.25rem;">
                                    <span class="question-type-badge" style="margin-right: 8px;">${typeLabel}</span>
                                    Q${index + 1}: ${questionText.substring(0, 80)}${questionText.length > 80 ? '...' : ''}
                                </div>
                            </div>
                            <button class="btn btn-secondary" onclick="editSelectorQuestion(${index}); event.stopPropagation();" style="padding: 0.5rem 1rem; font-size: 0.875rem; flex-shrink: 0;">Edit</button>
                        </div>
                    </div>
                `;
            }).join('');

            document.getElementById('questionSelectorModal').style.display = 'flex';
        }

        function closeSelectorModal() {
            document.getElementById('questionSelectorModal').style.display = 'none';
            currentSelectedSetId = null;
            editingSelectorQuestionIndex = null;
        }

        async function editSelectorQuestion(index) {
            const set = allQuestionSets.find(s => (s._id || s.id) === currentSelectedSetId);
            if (!set) {
                alert('Question set not found');
                return;
            }

            const question = set.questions[index];
            editingSelectorQuestionIndex = index;

            // Hide selector modal temporarily
            document.getElementById('questionSelectorModal').style.display = 'none';

            // Populate the question builder with existing data
            document.getElementById('builderQuestionType').value = question.type;
            document.getElementById('builderQuestionText').value = question.text || question.questionText;

            if (question.type === 'mcq') {
                // Clear existing options
                document.getElementById('optionsList').innerHTML = '';
                optionCount = 0;

                // Add options from the question
                question.options.forEach((optionText, idx) => {
                    const optionDiv = document.createElement('div');
                    optionDiv.style.cssText = 'display: flex; gap: 8px; margin-bottom: 8px; align-items: center;';
                    optionDiv.innerHTML = `
                        <input type="radio" name="correctAnswer" value="${idx}" ${idx === question.correctAnswer ? 'checked' : ''} style="width: 20px; height: 20px;">
                        <input type="text" class="option-input" value="${optionText}" placeholder="Option ${String.fromCharCode(65 + idx)}" required style="flex: 1; padding: 0.5rem; border: 1px solid #e5e7eb; border-radius: 6px;">
                        <button type="button" onclick="removeOption(this)" style="padding: 0.5rem; background: #ef4444; color: white; border: none; border-radius: 6px; cursor: pointer;">✕</button>
                    `;
                    document.getElementById('optionsList').appendChild(optionDiv);
                    optionCount++;
                });
            } else if (question.type === 'tf') {
                // True/False
                document.getElementById('builderTFAnswer').value = question.correctAnswer;
            } else if (question.type === 'fillblank') {
                // Fill-in-Blank
                const answers = Array.isArray(question.correctAnswer) ? question.correctAnswer : [question.correctAnswer];
                document.getElementById('builderFillBlankAnswers').value = answers.join('\n');
            }

            updateQuestionBuilderUI();
            document.getElementById('questionBuilderModal').style.display = 'flex';
        }

        async function saveSelectorQuestionEdit(updatedQuestion) {
            const set = allQuestionSets.find(s => (s._id || s.id) === currentSelectedSetId);
            if (!set) {
                alert('Question set not found');
                return;
            }

            // Update the question in the set
            set.questions[editingSelectorQuestionIndex] = updatedQuestion;

            // Save to database
            loading.show('Updating question...');
            try {
                await questionSets.update(currentSelectedSetId, {
                    name: set.name,
                    questions: set.questions
                });

                logger.debug('✅ Question updated in database');

                // Refresh the selector modal
                editingSelectorQuestionIndex = null;
                showQuestionSelector(currentSelectedSetId);

            } catch (error) {
                logger.error('Error updating question:', error);
                alert(`Failed to update question: ${error.message}`);
                // Re-show selector modal even on error
                editingSelectorQuestionIndex = null;
                document.getElementById('questionSelectorModal').style.display = 'flex';
            } finally {
                loading.hide();
            }
        }

        function selectAllQuestions() {
            document.querySelectorAll('.question-checkbox').forEach(cb => cb.checked = true);
        }

        function deselectAllQuestions() {
            document.querySelectorAll('.question-checkbox').forEach(cb => cb.checked = false);
        }

        function loadSelectedQuestions() {
            const set = allQuestionSets.find(s => (s._id || s.id) === currentSelectedSetId);
            if (!set) {
                alert('Question set not found');
                return;
            }

            // Get selected question indices
            const checkboxes = document.querySelectorAll('.question-checkbox');
            const selectedIndices = Array.from(checkboxes)
                .filter(cb => cb.checked)
                .map(cb => parseInt(cb.dataset.index));

            if (selectedIndices.length === 0) {
                alert('Please select at least one question');
                return;
            }

            // Get only selected questions and ensure they have timeLimit and points
            const selectedQuestions = selectedIndices.map(index => ({
                ...set.questions[index],
                timeLimit: set.questions[index].timeLimit || 60,
                points: set.questions[index].points || 10
            }));

            // Store in sessionStorage
            sessionStorage.setItem('pendingQuestions', JSON.stringify(selectedQuestions));
            sessionStorage.setItem('fromSavedSet', 'true');

            logger.debug(`✅ Loaded ${selectedQuestions.length} questions from "${set.name}"`);

            // Auto-navigate back
            const urlParams = new URLSearchParams(window.location.search);
            const returnUrl = urlParams.get('returnUrl') || sessionStorage.getItem('createSessionUrl');

            closeSelectorModal();

            if (returnUrl) {
                window.location.href = returnUrl;
            } else {
                alert(`✅ Loaded ${selectedQuestions.length} questions from "${set.name}"!\n\nGo back to the session page to use them.`);
            }
        }

        // ========== EDIT QUESTION SET FUNCTIONS ==========

        let editingSetId = null;

        function editQuestionSet(setId) {
            logger.debug('Opening editor for set:', setId);
            const set = allQuestionSets.find(s => (s._id || s.id) === setId);

            if (!set) {
                alert('Question set not found');
                return;
            }

            editingSetId = setId;
            newSetQuestions = [...set.questions]; // Copy questions
            currentEditingIndex = null;

            // Populate the create modal with existing data
            document.getElementById('newSetName').value = set.name;
            document.getElementById('saveButtonText').textContent = 'Update Question Set';
            renderNewQuestionsList();
            document.getElementById('createModal').style.display = 'flex';
        }

        async function updateQuestionSet() {
            const name = document.getElementById('newSetName').value.trim();

            if (!name) {
                alert('Please enter a question set name');
                return;
            }

            if (newSetQuestions.length === 0) {
                alert('Please add at least one question');
                return;
            }

            loading.show('Updating question set...');
            try {
                await questionSets.update(editingSetId, {
                    name: name,
                    questions: newSetQuestions
                });

                logger.debug('✅ Question set updated successfully');
                alert(`✅ Question set "${name}" updated successfully with ${newSetQuestions.length} questions!`);

                editingSetId = null;
                closeCreateModal();
                loadQuestionSets(); // Reload the list
            } catch (error) {
                logger.error('Error updating question set:', error);
                alert(`Failed to update question set: ${error.message}`);
            } finally {
                loading.hide();
            }
        }

        // ========== BULK SELECTION FUNCTIONS ==========

        function toggleSetSelection(setId) {
            if (selectedSets.has(setId)) {
                selectedSets.delete(setId);
            } else {
                selectedSets.add(setId);
            }
            renderQuestionSets(allQuestionSets);
        }

        function toggleSelectAll() {
            const visibleSets = allQuestionSets;

            if (selectedSets.size === visibleSets.length && visibleSets.length > 0) {
                // Deselect all
                selectedSets.clear();
            } else {
                // Select all visible
                visibleSets.forEach(set => {
                    const setId = set._id || set.id;
                    selectedSets.add(setId);
                });
            }

            renderQuestionSets(allQuestionSets);
        }

        function updateSelectionUI() {
            const count = selectedSets.size;
            document.getElementById('selectedCount').textContent = count;
            document.getElementById('deleteSelectedBtn').disabled = count === 0;

            const visibleSets = allQuestionSets;
            const allSelected = count > 0 && count === visibleSets.length;
            document.getElementById('selectAllText').textContent = allSelected ? 'Deselect All' : 'Select All';
        }

        async function deleteSelected() {
            const count = selectedSets.size;
            if (count === 0) return;

            const confirmed = await confirm(`Are you sure you want to delete ${count} question set${count > 1 ? 's' : ''}? This action cannot be undone.`);
            if (!confirmed) return;

            loading.show(`Deleting ${count} question set${count > 1 ? 's' : ''}...`);
            try {
                const deletePromises = Array.from(selectedSets).map(setId =>
                    questionSets.delete(setId)
                );

                await Promise.all(deletePromises);

                alert(`Successfully deleted ${count} question set${count > 1 ? 's' : ''}!`);
                selectedSets.clear();
                loadQuestionSets();
            } catch (error) {
                logger.error('Error deleting question sets:', error);
                alert('Some question sets could not be deleted. Please try again.');
                loadQuestionSets();
            } finally {
                loading.hide();
            }
        }

        checkAuth();

        // Expose functions to window object for onclick handlers
        window.toggleSelectAll = toggleSelectAll;
        window.deleteSelected = deleteSelected;
        window.showCreateQuestionSetModal = showCreateQuestionSetModal;
        window.closeCreateModal = closeCreateModal;
        window.addNewQuestion = addNewQuestion;
        window.updateQuestionSet = updateQuestionSet;
        window.saveNewQuestionSet = saveNewQuestionSet;
        window.closeQuestionBuilder = closeQuestionBuilder;
        window.updateQuestionBuilderUI = updateQuestionBuilderUI;
        window.addOption = addOption;
        window.removeOption = removeOption;
        window.saveQuestion = saveQuestion;
        window.editNewQuestion = editNewQuestion;
        window.removeNewQuestion = removeNewQuestion;
        window.selectAllQuestions = selectAllQuestions;
        window.deselectAllQuestions = deselectAllQuestions;
        window.closeSelectorModal = closeSelectorModal;
        window.loadSelectedQuestions = loadSelectedQuestions;
        window.editSelectorQuestion = editSelectorQuestion;
        window.toggleSetSelection = toggleSetSelection;
        window.showQuestionSelector = showQuestionSelector;
        window.editQuestionSet = editQuestionSet;
        window.viewQuestionSet = viewQuestionSet;
        window.deleteQuestionSet = deleteQuestionSet;
        window.filterQuestionSets = filterQuestionSets;
    </script>
</body>
</html>
