<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="version" content="1.0.4-full-edit">
    <title>Saved Question Sets - IntellaClick</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        .question-sets-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
            gap: 1.5rem;
            margin-top: 2rem;
        }

        .question-set-card {
            background: white;
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1.5rem;
            transition: all 0.2s;
        }

        .question-set-card:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            border-color: var(--primary-color);
        }

        .question-set-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 1rem;
        }

        .question-set-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }

        .question-set-meta {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .question-count-badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            background: var(--primary-color);
            color: white;
            border-radius: 20px;
            font-size: 0.875rem;
            font-weight: 600;
        }

        .question-preview {
            margin: 1rem 0;
            padding: 1rem;
            background: #f8f9fa;
            border-radius: 8px;
            max-height: 150px;
            overflow-y: auto;
        }

        .question-preview-item {
            padding: 0.5rem 0;
            border-bottom: 1px solid #dee2e6;
            font-size: 0.9rem;
        }

        .question-preview-item:last-child {
            border-bottom: none;
        }

        .question-type-badge {
            display: inline-block;
            padding: 0.125rem 0.5rem;
            background: #6c757d;
            color: white;
            border-radius: 4px;
            font-size: 0.75rem;
            margin-right: 0.5rem;
        }

        .question-set-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .empty-state {
            text-align: center;
            padding: 4rem 2rem;
            color: var(--text-secondary);
        }

        .empty-state svg {
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        .search-box {
            margin-bottom: 2rem;
        }

        .search-box input {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 1px solid var(--border);
            border-radius: 8px;
            font-size: 1rem;
        }

        .stats-bar {
            display: flex;
            gap: 2rem;
            padding: 1rem;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 2rem;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--primary-color);
        }

        .stat-label {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Saved Question Sets</h1>
            <button class="btn btn-secondary" onclick="window.history.back()">
                ← Back
            </button>
        </div>

        <div class="stats-bar">
            <div class="stat-item">
                <div class="stat-value" id="totalSets">0</div>
                <div class="stat-label">Question Sets</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="totalQuestions">0</div>
                <div class="stat-label">Total Questions</div>
            </div>
        </div>

        <div style="display: flex; gap: 12px; margin-bottom: 20px;">
            <div class="search-box" style="flex: 1; margin-bottom: 0;">
                <input type="text" id="searchInput" placeholder="Search question sets..." oninput="filterQuestionSets()">
            </div>
            <button class="btn btn-primary" onclick="showCreateQuestionSetModal()" style="white-space: nowrap;">
                ➕ Create New Question Set
            </button>
        </div>

        <div id="questionSetsContainer" class="question-sets-grid">
            <!-- Question sets will be loaded here -->
        </div>

        <div id="emptyState" class="empty-state" style="display: none;">
            <svg width="64" height="64" fill="currentColor">
                <path d="M6 9a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2V9Zm2-1a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1H8Z"/>
            </svg>
            <p style="font-size: 1.125rem; margin-bottom: 0.5rem;">No saved question sets yet</p>
            <p>Create a new question set or use questions from sessions</p>
        </div>
    </div>

    <!-- Create Question Set Modal -->
    <div id="createModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 10000; padding: 2rem; overflow-y: auto;">
        <div style="background: white; max-width: 800px; margin: 0 auto; border-radius: 12px; padding: 2rem;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; border-bottom: 1px solid #e5e7eb; padding-bottom: 1rem;">
                <h2 style="font-size: 1.5rem; font-weight: 700;">Create New Question Set</h2>
                <button onclick="closeCreateModal()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #6b7280;">&times;</button>
            </div>

            <!-- Question Set Name -->
            <div style="margin-bottom: 1.5rem;">
                <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Question Set Name *</label>
                <input type="text" id="newSetName" placeholder="e.g., Week 5 Review Questions" style="width: 100%; padding: 0.75rem; border: 1px solid #e5e7eb; border-radius: 8px; font-size: 1rem;">
            </div>

            <!-- Questions List -->
            <div style="margin-bottom: 1.5rem;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <label style="font-weight: 600;">Questions</label>
                    <button class="btn btn-secondary" onclick="addNewQuestion()" style="font-size: 0.875rem; padding: 0.5rem 1rem;">
                        ➕ Add Question
                    </button>
                </div>
                <div id="newQuestionsList"></div>
                <div id="emptyQuestions" style="text-align: center; padding: 2rem; color: #6b7280; background: #f9fafb; border-radius: 8px;">
                    <p>No questions added yet. Click "Add Question" to get started.</p>
                </div>
            </div>

            <!-- Action Buttons -->
            <div style="display: flex; gap: 12px; justify-content: flex-end;">
                <button class="btn btn-secondary" onclick="closeCreateModal()">Cancel</button>
                <button class="btn btn-primary" onclick="editingSetId ? updateQuestionSet() : saveNewQuestionSet()">
                    <span id="saveButtonText">Save Question Set</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Question Builder Modal -->
    <div id="questionBuilderModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.6); z-index: 10001; padding: 2rem; overflow-y: auto;">
        <div style="background: white; max-width: 700px; margin: 0 auto; border-radius: 12px; padding: 2rem;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
                <h3 style="font-size: 1.25rem; font-weight: 700;">Add Question</h3>
                <button onclick="closeQuestionBuilder()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer;">&times;</button>
            </div>

            <form id="questionBuilderForm" onsubmit="saveQuestion(event)">
                <!-- Question Type -->
                <div style="margin-bottom: 1rem;">
                    <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Question Type *</label>
                    <select id="builderQuestionType" onchange="updateQuestionBuilderUI()" style="width: 100%; padding: 0.75rem; border: 1px solid #e5e7eb; border-radius: 8px;">
                        <option value="mcq">Multiple Choice</option>
                        <option value="tf">True/False</option>
                    </select>
                </div>

                <!-- Question Text -->
                <div style="margin-bottom: 1rem;">
                    <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Question Text *</label>
                    <textarea id="builderQuestionText" rows="3" placeholder="Enter your question here..." required style="width: 100%; padding: 0.75rem; border: 1px solid #e5e7eb; border-radius: 8px; font-size: 1rem;"></textarea>
                </div>

                <!-- MCQ Options -->
                <div id="mcqOptions" style="margin-bottom: 1rem;">
                    <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Answer Options *</label>
                    <div id="optionsList"></div>
                    <button type="button" class="btn btn-secondary" onclick="addOption()" style="margin-top: 0.5rem; font-size: 0.875rem;">+ Add Option</button>
                </div>

                <!-- TF Options -->
                <div id="tfOptions" style="margin-bottom: 1rem; display: none;">
                    <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Correct Answer *</label>
                    <select id="builderTFAnswer" style="width: 100%; padding: 0.75rem; border: 1px solid #e5e7eb; border-radius: 8px;">
                        <option value="true">True</option>
                        <option value="false">False</option>
                    </select>
                </div>

                <!-- Action Buttons -->
                <div style="display: flex; gap: 12px; justify-content: flex-end; margin-top: 1.5rem;">
                    <button type="button" class="btn btn-secondary" onclick="closeQuestionBuilder()">Cancel</button>
                    <button type="submit" class="btn btn-primary">Add Question</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Question Selector Modal -->
    <div id="questionSelectorModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 10000; padding: 2rem; overflow-y: auto;">
        <div style="background: white; max-width: 800px; margin: 0 auto; border-radius: 12px; padding: 2rem;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; border-bottom: 1px solid #e5e7eb; padding-bottom: 1rem;">
                <h2 style="font-size: 1.5rem; font-weight: 700;">Select Questions to Use</h2>
                <button onclick="closeSelectorModal()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #6b7280;">&times;</button>
            </div>

            <div style="margin-bottom: 1rem; display: flex; gap: 12px;">
                <button class="btn btn-secondary" onclick="selectAllQuestions()">Select All</button>
                <button class="btn btn-secondary" onclick="deselectAllQuestions()">Deselect All</button>
            </div>

            <div id="questionCheckboxList" style="max-height: 400px; overflow-y: auto; margin-bottom: 1.5rem;">
                <!-- Checkboxes will be populated here -->
            </div>

            <div style="display: flex; gap: 12px; justify-content: flex-end;">
                <button class="btn btn-secondary" onclick="closeSelectorModal()">Cancel</button>
                <button class="btn btn-primary" onclick="loadSelectedQuestions()">Use Selected Questions</button>
            </div>
        </div>
    </div>

    <script>
        let allQuestionSets = [];

        console.log('🔵 Saved Questions Page Loaded - Version 1.0.2-button-fix');

        document.addEventListener('DOMContentLoaded', () => {
            console.log('🔵 DOMContentLoaded - initializing page');
            loadQuestionSets();
        });

        async function loadQuestionSets() {
            try {
                const token = localStorage.getItem('token');
                if (!token) {
                    throw new Error('Not authenticated. Please log in.');
                }

                console.log('Loading question sets from cloud API...');
                console.log('API URL: https://api.intellaclick.com/api/question-sets');
                console.log('Token present:', !!token);

                const response = await fetch('https://api.intellaclick.com/api/question-sets', {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });

                console.log('Response status:', response.status);

                if (!response.ok) {
                    let errorData;
                    try {
                        errorData = await response.json();
                    } catch (e) {
                        errorData = { error: `HTTP ${response.status}` };
                    }
                    console.error('Error response:', errorData);
                    throw new Error(errorData.error || `Failed to load question sets (${response.status})`);
                }

                const data = await response.json();
                allQuestionSets = data.questionSets || [];

                console.log(`✅ Loaded ${allQuestionSets.length} question sets from cloud`);

                // Update stats
                document.getElementById('totalSets').textContent = allQuestionSets.length;
                const totalQ = allQuestionSets.reduce((sum, set) => sum + (set.questionCount || set.questions?.length || 0), 0);
                document.getElementById('totalQuestions').textContent = totalQ;

                renderQuestionSets(allQuestionSets);
            } catch (error) {
                console.error('Error loading question sets:', error);
                console.error('Error details:', error.message);
                alert(`Failed to load question sets: ${error.message}\n\nThe backend may need to be restarted on Coolify.`);

                // Show empty state
                document.getElementById('totalSets').textContent = '0';
                document.getElementById('totalQuestions').textContent = '0';
                renderQuestionSets([]);
            }
        }

        function renderQuestionSets(sets) {
            const container = document.getElementById('questionSetsContainer');
            const emptyState = document.getElementById('emptyState');

            if (sets.length === 0) {
                container.style.display = 'none';
                emptyState.style.display = 'block';
                return;
            }

            container.style.display = 'grid';
            emptyState.style.display = 'none';

            container.innerHTML = sets.map((set, index) => {
                const date = new Date(set.createdAt).toLocaleDateString();
                const time = new Date(set.createdAt).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

                // Show first 3 questions as preview
                const preview = set.questions.slice(0, 3).map(q => {
                    const typeLabel = getTypeLabel(q.type);
                    const questionText = q.text || q.questionText || 'Question';
                    return `<div class="question-preview-item">
                        <span class="question-type-badge">${typeLabel}</span>
                        ${questionText.substring(0, 60)}${questionText.length > 60 ? '...' : ''}
                    </div>`;
                }).join('');

                const setId = set._id || set.id;

                return `
                    <div class="question-set-card">
                        <div class="question-set-header">
                            <div>
                                <div class="question-set-title">${set.name}</div>
                                <div class="question-set-meta">${date} at ${time}</div>
                            </div>
                            <span class="question-count-badge">${set.questionCount} Q's</span>
                        </div>

                        <div class="question-preview">
                            ${preview}
                            ${set.questions.length > 3 ? `<div style="text-align: center; padding: 0.5rem; color: var(--text-secondary); font-size: 0.875rem;">+ ${set.questions.length - 3} more questions</div>` : ''}
                        </div>

                        <div class="question-set-actions">
                            <button class="btn btn-primary" onclick="event.stopPropagation(); showQuestionSelector('${setId}')">
                                Use Questions
                            </button>
                            <button class="btn btn-secondary" onclick="event.stopPropagation(); editQuestionSet('${setId}')">
                                Edit
                            </button>
                            <button class="btn btn-secondary" onclick="event.stopPropagation(); viewQuestionSet('${setId}')">
                                View All
                            </button>
                            <button class="btn btn-danger" onclick="event.stopPropagation(); deleteQuestionSet('${setId}')">
                                Delete
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function getTypeLabel(type) {
            const labels = {
                'mcq': 'Multiple Choice',
                'tf': 'True/False',
                'matching': 'Matching',
                'ordering': 'Put in Order',
                'fillblank': 'Fill Blank'
            };
            return labels[type] || type;
        }

        function filterQuestionSets() {
            const search = document.getElementById('searchInput').value.toLowerCase();

            if (!search) {
                renderQuestionSets(allQuestionSets);
                return;
            }

            const filtered = allQuestionSets.filter(set =>
                set.name.toLowerCase().includes(search) ||
                set.questions.some(q =>
                    (q.text || q.questionText || '').toLowerCase().includes(search)
                )
            );

            renderQuestionSets(filtered);
        }

        function loadQuestionSet(setId) {
            console.log('=== loadQuestionSet CALLED ===');
            console.log('setId:', setId);
            console.log('allQuestionSets:', allQuestionSets);

            const set = allQuestionSets.find(s => {
                const id = s._id || s.id;
                console.log('Comparing:', id, '===', setId, '?', id === setId);
                return id === setId;
            });

            console.log('Found set:', set);

            if (!set) {
                alert('Question set not found. Check console for details.');
                return;
            }

            // Ensure all questions have timeLimit and points (for backward compatibility)
            const questionsWithDefaults = set.questions.map(q => ({
                ...q,
                timeLimit: q.timeLimit || 60,
                points: q.points || 10
            }));

            // Store in sessionStorage
            sessionStorage.setItem('pendingQuestions', JSON.stringify(questionsWithDefaults));
            sessionStorage.setItem('fromSavedSet', 'true');

            console.log('✅ Questions saved to sessionStorage');

            // Get the classId from URL or sessionStorage to navigate back
            const urlParams = new URLSearchParams(window.location.search);
            const returnUrl = urlParams.get('returnUrl') || sessionStorage.getItem('createSessionUrl');

            if (returnUrl) {
                // Automatically navigate back to create-session page
                console.log('Navigating back to:', returnUrl);
                window.location.href = returnUrl;
            } else {
                // Fallback: show alert if we don't know where to return
                alert(`✅ Loaded "${set.name}" with ${set.questionCount} questions!\n\nGo back to the session page to use them.`);
            }
        }

        function viewQuestionSet(setId) {
            console.log('Viewing question set:', setId);
            const set = allQuestionSets.find(s => (s._id || s.id) === setId);

            if (!set) {
                alert('Question set not found');
                return;
            }

            let details = `<div style="max-width: 600px; text-align: left;">
                <h3>${set.name}</h3>
                <p><strong>Created:</strong> ${new Date(set.createdAt).toLocaleString()}</p>
                <p><strong>Questions:</strong> ${set.questionCount}</p>
                <hr style="margin: 1rem 0;">`;

            set.questions.forEach((q, i) => {
                const typeLabel = getTypeLabel(q.type);
                details += `<div style="margin-bottom: 1rem; padding: 1rem; background: #f8f9fa; border-radius: 8px;">
                    <strong>${i + 1}. [${typeLabel}]</strong><br>
                    ${q.text || q.questionText}
                </div>`;
            });

            details += '</div>';

            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 10000; padding: 2rem;';
            modal.innerHTML = `<div style="background: white; padding: 2rem; border-radius: 12px; max-height: 80vh; overflow-y: auto; max-width: 800px;">${details}<button class="btn btn-primary" onclick="this.closest('div[style*=fixed]').remove()" style="margin-top: 1rem; width: 100%;">Close</button></div>`;
            document.body.appendChild(modal);

            modal.addEventListener('click', (e) => {
                if (e.target === modal) modal.remove();
            });
        }

        async function deleteQuestionSet(setId) {
            console.log('Deleting question set:', setId);
            const set = allQuestionSets.find(s => (s._id || s.id) === setId);

            if (!set) {
                alert('Question set not found');
                return;
            }

            if (!confirm(`Delete "${set.name}"?\n\nThis cannot be undone.`)) return;

            try {
                const token = localStorage.getItem('token');
                const response = await fetch(`https://api.intellaclick.com/api/question-sets/${setId}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Failed to delete question set');
                }

                console.log('✅ Question set deleted successfully');
                alert('Question set deleted successfully');

                // Reload the list
                loadQuestionSets();
            } catch (error) {
                console.error('Error deleting question set:', error);
                alert(`Failed to delete question set: ${error.message}`);
            }
        }

        function checkAuth() {
            const token = localStorage.getItem('token');
            if (!token) {
                window.location.href = '/login.html';
            }
        }

        // ========== CREATE QUESTION SET FUNCTIONS ==========

        let newSetQuestions = [];
        let currentEditingIndex = null;

        function showCreateQuestionSetModal() {
            newSetQuestions = [];
            currentEditingIndex = null;
            editingSetId = null;
            document.getElementById('newSetName').value = '';
            document.getElementById('newQuestionsList').innerHTML = '';
            document.getElementById('emptyQuestions').style.display = 'block';
            document.getElementById('saveButtonText').textContent = 'Save Question Set';
            document.getElementById('createModal').style.display = 'flex';
        }

        function closeCreateModal() {
            document.getElementById('createModal').style.display = 'none';
            editingSetId = null;
        }

        function addNewQuestion() {
            // Open question builder modal
            currentEditingIndex = null;
            document.getElementById('builderQuestionText').value = '';
            document.getElementById('builderQuestionType').value = 'mcq';
            document.getElementById('optionsList').innerHTML = '';
            optionCount = 0; // Reset option count
            updateQuestionBuilderUI();
            document.getElementById('questionBuilderModal').style.display = 'flex';
        }

        function closeQuestionBuilder() {
            document.getElementById('questionBuilderModal').style.display = 'none';

            // If we were editing from selector and cancelled, re-show selector
            if (editingSelectorQuestionIndex !== null) {
                editingSelectorQuestionIndex = null;
                document.getElementById('questionSelectorModal').style.display = 'flex';
            }
        }

        function updateQuestionBuilderUI() {
            const type = document.getElementById('builderQuestionType').value;

            if (type === 'tf') {
                document.getElementById('mcqOptions').style.display = 'none';
                document.getElementById('tfOptions').style.display = 'block';
            } else {
                document.getElementById('mcqOptions').style.display = 'block';
                document.getElementById('tfOptions').style.display = 'none';

                // Initialize with 4 options for MCQ if empty
                const optionsList = document.getElementById('optionsList');
                if (optionsList.children.length === 0) {
                    for (let i = 0; i < 4; i++) {
                        addOption();
                    }
                }
            }
        }

        let optionCount = 0;

        function addOption() {
            const optionsList = document.getElementById('optionsList');
            const index = optionCount++;

            const optionDiv = document.createElement('div');
            optionDiv.style.cssText = 'display: flex; gap: 8px; margin-bottom: 8px; align-items: center;';
            optionDiv.innerHTML = `
                <input type="radio" name="correctAnswer" value="${index}" ${index === 0 ? 'checked' : ''} style="width: 20px; height: 20px;">
                <input type="text" class="option-input" placeholder="Option ${String.fromCharCode(65 + index)}" required style="flex: 1; padding: 0.5rem; border: 1px solid #e5e7eb; border-radius: 6px;">
                <button type="button" onclick="removeOption(this)" style="padding: 0.5rem; background: #ef4444; color: white; border: none; border-radius: 6px; cursor: pointer;">✕</button>
            `;
            optionsList.appendChild(optionDiv);
        }

        function removeOption(btn) {
            const optionsList = document.getElementById('optionsList');
            if (optionsList.children.length > 2) {
                btn.parentElement.remove();
            } else {
                alert('You must have at least 2 options');
            }
        }

        async function saveQuestion(event) {
            event.preventDefault();
            console.log('=== saveQuestion called ===');
            console.log('currentEditingIndex:', currentEditingIndex);
            console.log('editingSelectorQuestionIndex:', editingSelectorQuestionIndex);

            try {
                const type = document.getElementById('builderQuestionType').value;
                const text = document.getElementById('builderQuestionText').value.trim();

                console.log('Question type:', type);
                console.log('Question text:', text);

                if (!text) {
                    alert('Please enter question text');
                    return;
                }

                const question = {
                    type: type,
                    text: text
                };

                if (type === 'mcq') {
                    const options = Array.from(document.querySelectorAll('.option-input')).map(input => input.value.trim());
                    const correctIndex = parseInt(document.querySelector('input[name="correctAnswer"]:checked').value);

                    console.log('MCQ options:', options);
                    console.log('Correct index:', correctIndex);

                    if (options.some(opt => !opt)) {
                        alert('Please fill in all options');
                        return;
                    }

                    question.options = options;
                    question.correctAnswer = correctIndex;
                } else {
                    question.correctAnswer = document.getElementById('builderTFAnswer').value;
                    console.log('TF correct answer:', question.correctAnswer);
                }

                // Check if we're editing from the selector modal
                if (editingSelectorQuestionIndex !== null) {
                    closeQuestionBuilder();
                    await saveSelectorQuestionEdit(question);
                    return;
                }

                // Otherwise, handle normal create/edit flow
                if (currentEditingIndex !== null) {
                    // Update existing question in newSetQuestions
                    newSetQuestions[currentEditingIndex] = question;
                    console.log('✅ Question updated at index:', currentEditingIndex);
                } else {
                    // Add new question
                    newSetQuestions.push(question);
                    console.log('✅ Question added. Total questions:', newSetQuestions.length);
                }

                renderNewQuestionsList();
                closeQuestionBuilder();

                // Reset for next question
                currentEditingIndex = null;
                optionCount = 0;
                document.getElementById('optionsList').innerHTML = '';
            } catch (error) {
                console.error('❌ Error saving question:', error);
                alert('Error saving question: ' + error.message);
            }
        }

        function renderNewQuestionsList() {
            const container = document.getElementById('newQuestionsList');
            const emptyState = document.getElementById('emptyQuestions');

            if (newSetQuestions.length === 0) {
                container.innerHTML = '';
                emptyState.style.display = 'block';
                return;
            }

            emptyState.style.display = 'none';
            container.innerHTML = newSetQuestions.map((q, index) => `
                <div style="background: #f9fafb; padding: 1rem; border-radius: 8px; margin-bottom: 0.75rem; display: flex; justify-content: space-between; align-items: start;">
                    <div style="flex: 1;">
                        <div style="font-weight: 600; margin-bottom: 0.25rem;">Q${index + 1}: ${q.text}</div>
                        <div style="font-size: 0.875rem; color: #6b7280;">Type: ${q.type === 'mcq' ? 'Multiple Choice' : 'True/False'}</div>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button class="btn btn-secondary" onclick="editNewQuestion(${index})" style="padding: 0.5rem 1rem; font-size: 0.875rem;">Edit</button>
                        <button class="btn btn-danger" onclick="removeNewQuestion(${index})" style="padding: 0.5rem 1rem; font-size: 0.875rem;">Remove</button>
                    </div>
                </div>
            `).join('');
        }

        function editNewQuestion(index) {
            const question = newSetQuestions[index];
            currentEditingIndex = index;

            // Populate the question builder with existing data
            document.getElementById('builderQuestionType').value = question.type;
            document.getElementById('builderQuestionText').value = question.text;

            if (question.type === 'mcq') {
                // Clear existing options
                document.getElementById('optionsList').innerHTML = '';
                optionCount = 0;

                // Add options from the question
                question.options.forEach((optionText, idx) => {
                    const optionDiv = document.createElement('div');
                    optionDiv.style.cssText = 'display: flex; gap: 8px; margin-bottom: 8px; align-items: center;';
                    optionDiv.innerHTML = `
                        <input type="radio" name="correctAnswer" value="${idx}" ${idx === question.correctAnswer ? 'checked' : ''} style="width: 20px; height: 20px;">
                        <input type="text" class="option-input" value="${optionText}" placeholder="Option ${String.fromCharCode(65 + idx)}" required style="flex: 1; padding: 0.5rem; border: 1px solid #e5e7eb; border-radius: 6px;">
                        <button type="button" onclick="removeOption(this)" style="padding: 0.5rem; background: #ef4444; color: white; border: none; border-radius: 6px; cursor: pointer;">✕</button>
                    `;
                    document.getElementById('optionsList').appendChild(optionDiv);
                    optionCount++;
                });
            } else {
                // True/False
                document.getElementById('builderTFAnswer').value = question.correctAnswer;
            }

            updateQuestionBuilderUI();
            document.getElementById('questionBuilderModal').style.display = 'flex';
        }

        function removeNewQuestion(index) {
            newSetQuestions.splice(index, 1);
            renderNewQuestionsList();
        }

        async function saveNewQuestionSet() {
            const name = document.getElementById('newSetName').value.trim();

            if (!name) {
                alert('Please enter a question set name');
                return;
            }

            if (newSetQuestions.length === 0) {
                alert('Please add at least one question');
                return;
            }

            try {
                const token = localStorage.getItem('token');
                const response = await fetch('https://api.intellaclick.com/api/question-sets', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        name: name,
                        questions: newSetQuestions
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Failed to save question set');
                }

                console.log('✅ Question set saved successfully');
                alert(`✅ Question set "${name}" created successfully with ${newSetQuestions.length} questions!`);

                closeCreateModal();
                loadQuestionSets(); // Reload the list
            } catch (error) {
                console.error('Error saving question set:', error);
                alert(`Failed to save question set: ${error.message}`);
            }
        }

        // ========== QUESTION SELECTOR FUNCTIONS ==========

        let currentSelectedSetId = null;
        let editingSelectorQuestionIndex = null;

        function showQuestionSelector(setId) {
            console.log('Opening question selector for set:', setId);
            const set = allQuestionSets.find(s => (s._id || s.id) === setId);

            if (!set) {
                alert('Question set not found');
                return;
            }

            currentSelectedSetId = setId;

            // Populate checkbox list
            const container = document.getElementById('questionCheckboxList');
            container.innerHTML = set.questions.map((q, index) => {
                const typeLabel = getTypeLabel(q.type);
                const questionText = q.text || q.questionText || 'Question';
                return `
                    <div style="padding: 1rem; background: #f9fafb; border-radius: 8px; margin-bottom: 0.75rem;">
                        <div style="display: flex; align-items: start; gap: 12px;">
                            <input type="checkbox" class="question-checkbox" data-index="${index}" checked style="width: 20px; height: 20px; margin-top: 2px; flex-shrink: 0;">
                            <div style="flex: 1;">
                                <div style="font-weight: 600; margin-bottom: 0.25rem;">
                                    <span class="question-type-badge" style="margin-right: 8px;">${typeLabel}</span>
                                    Q${index + 1}: ${questionText.substring(0, 80)}${questionText.length > 80 ? '...' : ''}
                                </div>
                            </div>
                            <button class="btn btn-secondary" onclick="editSelectorQuestion(${index}); event.stopPropagation();" style="padding: 0.5rem 1rem; font-size: 0.875rem; flex-shrink: 0;">Edit</button>
                        </div>
                    </div>
                `;
            }).join('');

            document.getElementById('questionSelectorModal').style.display = 'flex';
        }

        function closeSelectorModal() {
            document.getElementById('questionSelectorModal').style.display = 'none';
            currentSelectedSetId = null;
            editingSelectorQuestionIndex = null;
        }

        async function editSelectorQuestion(index) {
            const set = allQuestionSets.find(s => (s._id || s.id) === currentSelectedSetId);
            if (!set) {
                alert('Question set not found');
                return;
            }

            const question = set.questions[index];
            editingSelectorQuestionIndex = index;

            // Hide selector modal temporarily
            document.getElementById('questionSelectorModal').style.display = 'none';

            // Populate the question builder with existing data
            document.getElementById('builderQuestionType').value = question.type;
            document.getElementById('builderQuestionText').value = question.text || question.questionText;

            if (question.type === 'mcq') {
                // Clear existing options
                document.getElementById('optionsList').innerHTML = '';
                optionCount = 0;

                // Add options from the question
                question.options.forEach((optionText, idx) => {
                    const optionDiv = document.createElement('div');
                    optionDiv.style.cssText = 'display: flex; gap: 8px; margin-bottom: 8px; align-items: center;';
                    optionDiv.innerHTML = `
                        <input type="radio" name="correctAnswer" value="${idx}" ${idx === question.correctAnswer ? 'checked' : ''} style="width: 20px; height: 20px;">
                        <input type="text" class="option-input" value="${optionText}" placeholder="Option ${String.fromCharCode(65 + idx)}" required style="flex: 1; padding: 0.5rem; border: 1px solid #e5e7eb; border-radius: 6px;">
                        <button type="button" onclick="removeOption(this)" style="padding: 0.5rem; background: #ef4444; color: white; border: none; border-radius: 6px; cursor: pointer;">✕</button>
                    `;
                    document.getElementById('optionsList').appendChild(optionDiv);
                    optionCount++;
                });
            } else {
                // True/False
                document.getElementById('builderTFAnswer').value = question.correctAnswer;
            }

            updateQuestionBuilderUI();
            document.getElementById('questionBuilderModal').style.display = 'flex';
        }

        async function saveSelectorQuestionEdit(updatedQuestion) {
            const set = allQuestionSets.find(s => (s._id || s.id) === currentSelectedSetId);
            if (!set) {
                alert('Question set not found');
                return;
            }

            // Update the question in the set
            set.questions[editingSelectorQuestionIndex] = updatedQuestion;

            // Save to database
            try {
                const token = localStorage.getItem('token');
                const response = await fetch(`https://api.intellaclick.com/api/question-sets/${currentSelectedSetId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        name: set.name,
                        questions: set.questions
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Failed to update question');
                }

                console.log('✅ Question updated in database');

                // Refresh the selector modal
                editingSelectorQuestionIndex = null;
                showQuestionSelector(currentSelectedSetId);

            } catch (error) {
                console.error('Error updating question:', error);
                alert(`Failed to update question: ${error.message}`);
                // Re-show selector modal even on error
                editingSelectorQuestionIndex = null;
                document.getElementById('questionSelectorModal').style.display = 'flex';
            }
        }

        function selectAllQuestions() {
            document.querySelectorAll('.question-checkbox').forEach(cb => cb.checked = true);
        }

        function deselectAllQuestions() {
            document.querySelectorAll('.question-checkbox').forEach(cb => cb.checked = false);
        }

        function loadSelectedQuestions() {
            const set = allQuestionSets.find(s => (s._id || s.id) === currentSelectedSetId);
            if (!set) {
                alert('Question set not found');
                return;
            }

            // Get selected question indices
            const checkboxes = document.querySelectorAll('.question-checkbox');
            const selectedIndices = Array.from(checkboxes)
                .filter(cb => cb.checked)
                .map(cb => parseInt(cb.dataset.index));

            if (selectedIndices.length === 0) {
                alert('Please select at least one question');
                return;
            }

            // Get only selected questions and ensure they have timeLimit and points
            const selectedQuestions = selectedIndices.map(index => ({
                ...set.questions[index],
                timeLimit: set.questions[index].timeLimit || 60,
                points: set.questions[index].points || 10
            }));

            // Store in sessionStorage
            sessionStorage.setItem('pendingQuestions', JSON.stringify(selectedQuestions));
            sessionStorage.setItem('fromSavedSet', 'true');

            console.log(`✅ Loaded ${selectedQuestions.length} questions from "${set.name}"`);

            // Auto-navigate back
            const urlParams = new URLSearchParams(window.location.search);
            const returnUrl = urlParams.get('returnUrl') || sessionStorage.getItem('createSessionUrl');

            closeSelectorModal();

            if (returnUrl) {
                window.location.href = returnUrl;
            } else {
                alert(`✅ Loaded ${selectedQuestions.length} questions from "${set.name}"!\n\nGo back to the session page to use them.`);
            }
        }

        // ========== EDIT QUESTION SET FUNCTIONS ==========

        let editingSetId = null;

        function editQuestionSet(setId) {
            console.log('Opening editor for set:', setId);
            const set = allQuestionSets.find(s => (s._id || s.id) === setId);

            if (!set) {
                alert('Question set not found');
                return;
            }

            editingSetId = setId;
            newSetQuestions = [...set.questions]; // Copy questions
            currentEditingIndex = null;

            // Populate the create modal with existing data
            document.getElementById('newSetName').value = set.name;
            document.getElementById('saveButtonText').textContent = 'Update Question Set';
            renderNewQuestionsList();
            document.getElementById('createModal').style.display = 'flex';
        }

        async function updateQuestionSet() {
            const name = document.getElementById('newSetName').value.trim();

            if (!name) {
                alert('Please enter a question set name');
                return;
            }

            if (newSetQuestions.length === 0) {
                alert('Please add at least one question');
                return;
            }

            try {
                const token = localStorage.getItem('token');
                const response = await fetch(`https://api.intellaclick.com/api/question-sets/${editingSetId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        name: name,
                        questions: newSetQuestions
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Failed to update question set');
                }

                console.log('✅ Question set updated successfully');
                alert(`✅ Question set "${name}" updated successfully with ${newSetQuestions.length} questions!`);

                editingSetId = null;
                closeCreateModal();
                loadQuestionSets(); // Reload the list
            } catch (error) {
                console.error('Error updating question set:', error);
                alert(`Failed to update question set: ${error.message}`);
            }
        }

        checkAuth();
    </script>
</body>
</html>
